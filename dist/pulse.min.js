(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.Pulse = factory());
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var protectedNames = [
        'data',
        'indexes',
        'groups',
        'computed',
        'actions',
        'routes'
    ];
    var collectionFunctions = [
        'collect',
        'replaceIndex',
        'getGroup',
        'newGroup',
        'deleteGroup',
        'removeFromGroup',
        'update',
        'increment',
        'decrement',
        'delete',
        'purge',
        'watch',
        'findById',
        'put',
        'move',
        'throttle',
        // deprecated
        'remove'
    ];
    function defineConfig(config, defaults) {
        return __assign({}, defaults, config);
    }
    function uuid() {
        return (Math.random()
            .toString()
            .split('.')[1] + Date.now());
    }
    function objectLoop(object, callback, keys) {
        var objectKeys = keys ? keys : Object.keys(object);
        for (var i = 0; i < objectKeys.length; i++) {
            var key = objectKeys[i];
            var value = object[key];
            callback(key, value, objectKeys);
        }
    }
    // const thing = {}
    // objectLoop(thing, (thingKey, thingItem) => {
    // })
    function log(value, payload) {
        // console.log(`Pulse / ${value}`, payload ? payload : ' ');
    }
    function normalizeMap(map) {
        return Array.isArray(map)
            ? map.map(function (key) { return ({ key: key, val: key }); })
            : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); });
    }
    var arrayFunctions = [
        'push',
        'pop',
        'shift',
        'unshift',
        'splice',
        'sort',
        'reverse'
    ];
    function assert(func, funcName) {
        function warn(message) {
            // if (funcName) console.log(`PULSE // "${funcName}()" :: ${message}`);
            // else console.warn(`PULSE :: ${message}`);
            return false;
        }
        var warnings = {
            NO_PRIMARY_KEY: function () { return warn(); },
            INVALID_PARAMETER: function () { return warn(); },
            INDEX_NOT_FOUND: function () { return warn(); },
            INTERNAL_DATA_NOT_FOUND: function () { return warn(); },
            PROPERTY_NOT_A_NUMBER: function () { return warn(); }
        };
        return func(warnings)();
    }
    function isWatchableObject(value) {
        function isHTMLElement(obj) {
            try {
                return obj instanceof HTMLElement;
            }
            catch (e) {
                return (typeof obj === 'object' &&
                    obj.nodeType === 1 &&
                    typeof obj.style === 'object' &&
                    typeof obj.ownerDocument === 'object');
            }
        }
        var type = typeof value;
        return (value != null &&
            type == 'object' &&
            !isHTMLElement(value) &&
            !Array.isArray(value));
    }
    function validateNumber(mutable, amount) {
        if (typeof amount !== 'number' || typeof mutable !== 'number') {
            return false;
        }
        return true;
    }
    //# sourceMappingURL=helpers.js.map

    var JobType;
    (function (JobType) {
        JobType["PUBLIC_DATA_MUTATION"] = "PUBLIC_DATA_MUTATION";
        JobType["INTERNAL_DATA_MUTATION"] = "INTERNAL_DATA_MUTATION";
        JobType["INDEX_UPDATE"] = "INDEX_UPDATE";
        JobType["COMPUTED_REGEN"] = "COMPUTED_REGEN";
        JobType["GROUP_UPDATE"] = "GROUP_UPDATE";
        JobType["DEEP_PUBLIC_DATA_MUTATION"] = "DEEP_PUBLIC_DATA_MUTATION";
        JobType["BULK_INTERNAL_DATA_MUTATION"] = "BULK_INTERNAL_DATA_MUTATION";
        JobType["DELETE_INTERNAL_DATA"] = "DELETE_INTERNAL_DATA";
    })(JobType || (JobType = {}));
    //# sourceMappingURL=interfaces.js.map

    var Runtime = /** @class */ (function () {
        function Runtime(collections, global) {
            this.collections = collections;
            this.global = global;
            this.running = false;
            this.updatingSubscribers = false;
            this.ingestQueue = [];
            this.completedJobs = [];
            this.archivedJobs = [];
            global.ingest = this.ingest.bind(this);
            global.searchIndexes = this.searchIndexes.bind(this);
            this.config = global.config;
        }
        Runtime.prototype.ingest = function (job) {
            // if (
            //   job.property === 'feed' &&
            //   job.type === JobType.INDEX_UPDATE &&
            //   job.value.length > 60
            // )
            //   debugger;
            this.ingestQueue.push(job);
            if (!this.running) {
                this.findNextJob();
            }
        };
        Runtime.prototype.findNextJob = function () {
            this.running = true;
            var next = this.ingestQueue.shift();
            // non public data properties such as groups, computed and indexes will not have their dep, so get it.
            if (!next.dep)
                next.dep = this.collections[next.collection].public.getDep(next.property);
            // execute the next task in the queue
            this.performJob(next);
        };
        Runtime.prototype.performJob = function (job) {
            var _this = this;
            switch (job.type) {
                case JobType.PUBLIC_DATA_MUTATION:
                    this.performPublicDataUpdate(job);
                    this.collections[job.collection].runWatchers(job.property);
                    break;
                case JobType.INTERNAL_DATA_MUTATION:
                    this.performInternalDataUpdate(job);
                    break;
                case JobType.BULK_INTERNAL_DATA_MUTATION:
                    // this.performInternalDataUpdate(collection, property, value);
                    break;
                case JobType.INDEX_UPDATE:
                    this.performIndexUpdate(job);
                    break;
                case JobType.COMPUTED_REGEN:
                    this.performComputedOutput(job);
                    this.collections[job.collection].runWatchers(job.property.name);
                    break;
                case JobType.GROUP_UPDATE:
                    this.performGroupRebuild(job);
                    this.collections[job.collection].runWatchers(job.property);
                    break;
                case JobType.DELETE_INTERNAL_DATA:
                    this.performInternalDataDeletion(job);
                    break;
                default:
                    break;
            }
            // unpack dependent computed
            if (job.dep && job.dep.dependents.size > 0) {
                // log(`Queueing ${dep.dependents.size} dependents`);
                job.dep.dependents.forEach(function (computed) {
                    // get dep from public computed output
                    _this.ingest({
                        type: JobType.COMPUTED_REGEN,
                        collection: computed.collection,
                        property: computed,
                        dep: _this.collections[computed.collection].public.getDep(computed.name)
                    });
                });
            }
            this.finished();
        };
        Runtime.prototype.finished = function () {
            var _this = this;
            this.running = false;
            if (this.completedJobs.length > 5000)
                return;
            // If there's already more stuff in the queue, loop.
            if (this.ingestQueue.length > 0) {
                this.findNextJob();
                return;
            }
            // Wait until callstack is empty to check if we should finalise this body of work
            setTimeout(function () {
                if (_this.ingestQueue.length === 0) {
                    if (!_this.updatingSubscribers)
                        _this.compileComponentUpdates();
                    _this.cleanup();
                }
                else {
                    // loop more!
                    _this.findNextJob();
                }
            });
        };
        // Jobs runtime can perform
        Runtime.prototype.performPublicDataUpdate = function (job) {
            this.writeToPublicObject(job.collection, 'data', job.property, job.value);
            this.completedJob(job);
        };
        Runtime.prototype.performInternalDataUpdate = function (job) {
            job.previousValue = this.overwriteInternalData(job.collection, job.property, job.value);
            // only look for indexes if we're not collecting data
            if (this.global.collecting) ;
            // find and ingest direct depenecies on data
            this.global.relations.internalDataModified(job.collection, job.property);
            this.findIndexesToUpdate(job.collection, job.property);
            this.completedJob(job);
        };
        Runtime.prototype.performInternalDataDeletion = function (job) {
            var c = this.collections[job.collection];
            // preserve previous value
            job.previousValue = __assign({}, c.internalData[job.property]);
            // delete data
            delete c.internalData[job.property];
            // find indexes affected by this data deletion
            var indexesToUpdate = this.searchIndexes(job.collection, job.property);
            // for each found index, perform index update
            for (var i = 0; i < indexesToUpdate.length; i++) {
                var indexName = indexesToUpdate[i];
                var newIndex = c.indexes.object[indexName].slice().filter(function (id) { return id !== job.property; });
                this.ingest({
                    type: JobType.INDEX_UPDATE,
                    collection: c.name,
                    property: indexName,
                    value: newIndex,
                    dep: this.collections[job.collection].public.getDep(job.property)
                });
            }
            this.completedJob(job);
        };
        Runtime.prototype.performIndexUpdate = function (job) {
            // preserve old index
            job.previousValue = this.collections[job.collection].indexes[job.property];
            // Update Index
            this.collections[job.collection].indexes.privateWrite(job.property, job.value);
            this.completedJob(job);
            // Group must also be updated
            this.ingest({
                type: JobType.GROUP_UPDATE,
                collection: job.collection,
                property: job.property,
                dep: this.collections[job.collection].public.getDep(job.property)
            });
        };
        Runtime.prototype.performGroupRebuild = function (job) {
            job.value = this.collections[job.collection].buildGroupFromIndex(job.property);
            this.ingestForeignRelatedGroups(job.collection, job.property);
            this.writeToPublicObject(job.collection, 'group', job.property, job.value);
            this.completedJob(job);
        };
        Runtime.prototype.performComputedOutput = function (job) {
            var computed = typeof job.property === 'string'
                ? this.collections[job.collection].computed[job.property]
                : job.property;
            job.value = computed.run();
            // Commit Update
            this.writeToPublicObject(job.collection, 'computed', computed.name, job.value);
            this.completedJob(job);
        };
        // Handlers for committing updates
        Runtime.prototype.writeToPublicObject = function (collection, type, key, value) {
            if (type === 'indexes') {
                if (!this.collections[collection][type].object.hasOwnProperty(key))
                    return;
                this.collections[collection][type].privateWrite(key, value);
            }
            else {
                if (!this.collections[collection].public.object.hasOwnProperty(key))
                    return;
                this.collections[collection].public.privateWrite(key, value);
            }
        };
        Runtime.prototype.completedJob = function (job) {
            job.fromAction = this.global.runningAction;
            if (this.global.initComplete)
                this.completedJobs.push(job);
            this.persistData(job);
        };
        Runtime.prototype.compileComponentUpdates = function () {
            if (!this.global.initComplete)
                return;
            this.updatingSubscribers = true;
            log('ALL JOBS COMPLETE', this.completedJobs);
            var componentsToUpdate = {};
            var subscribe = function (value, subscribers) {
                for (var i = 0; i < subscribers.length; i++) {
                    var uuid = subscribers[i].componentUUID;
                    var key = subscribers[i].key;
                    if (!componentsToUpdate[uuid]) {
                        componentsToUpdate[uuid] = {};
                        componentsToUpdate[uuid][key] = value;
                    }
                    else {
                        componentsToUpdate[uuid][key] = value;
                    }
                }
            };
            for (var i = 0; i < this.completedJobs.length; i++) {
                var job = this.completedJobs[i];
                if (job.dep)
                    subscribe(job.value, job.dep.subscribers);
            }
            this.updateSubscribers(componentsToUpdate);
            this.completedJobs = [];
        };
        Runtime.prototype.updateSubscribers = function (componentsToUpdate) {
            var componentKeys = Object.keys(componentsToUpdate);
            var _loop_1 = function (i) {
                var componentID = componentKeys[i];
                var componentInstance = this_1.global.subs.componentStore[componentID];
                if (!componentInstance || !componentInstance.instance)
                    return { value: void 0 };
                var propertiesToUpdate = componentsToUpdate[componentID];
                var dataKeys = Object.keys(propertiesToUpdate);
                // Switch depending on framework
                switch (this_1.global.config.framework) {
                    case 'vue':
                        dataKeys.forEach(function (property) {
                            var value = propertiesToUpdate[property];
                            componentInstance.instance.$set(componentInstance.instance, property, value);
                        });
                        break;
                    case 'react':
                        componentInstance.instance.setState(propertiesToUpdate);
                        break;
                    default:
                        break;
                }
            };
            var this_1 = this;
            for (var i = 0; i < componentKeys.length; i++) {
                var state_1 = _loop_1(i);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        };
        Runtime.prototype.persistData = function (job) {
            if (job.type === JobType.INTERNAL_DATA_MUTATION)
                return;
            if (this.collections[job.collection].persist.includes(job.property)) {
                this.global.storage.set(job.collection, job.property, job.value);
            }
        };
        Runtime.prototype.cleanup = function () {
            var _this = this;
            setTimeout(function () {
                _this.updatingSubscribers = false;
            });
        };
        Runtime.prototype.findIndexesToUpdate = function (collection, keys) {
            var foundIndexes = new Set();
            var c = this.collections[collection];
            if (!Array.isArray(keys))
                keys = [keys];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var searchIndexes = this.searchIndexes(collection, key);
                searchIndexes.forEach(function (index) { return foundIndexes.add(index); });
            }
            // foundIndexes.forEach((index: string) => {
            //   this.ingest({
            //     type: JobType.INDEX_UPDATE,
            //     collection: c.name,
            //     property: index,
            //     dep: this.collections[c.name].indexes.getDep(index)
            //   });
            // });
        };
        // when groups are rebuilt, find other groups that are dependent on this group
        // (defined using "hasMany" in the model) and ingest those groups into the queue.
        Runtime.prototype.ingestForeignRelatedGroups = function (collection, groupName) {
            var _this = this;
            var relations = this.collections[collection].foreignGroupRelations;
            objectLoop(relations, function (relationKey, relation) {
                if (relationKey === groupName)
                    _this.ingest({
                        type: JobType.GROUP_UPDATE,
                        collection: relation.collection,
                        property: relation.groupToRegen,
                        dep: _this.collections[relation.collection].public.getDep(relation.groupToRegen)
                    });
            });
        };
        Runtime.prototype.searchIndexes = function (collection, primaryKey) {
            var c = this.collections[collection];
            var keys = Object.keys(c.indexes.object);
            var foundIndexes = [];
            for (var i = 0; i < keys.length; i++) {
                var indexName = keys[i];
                if (c.indexes.object[indexName].includes(primaryKey))
                    foundIndexes.push(indexName);
            }
            return foundIndexes;
        };
        Runtime.prototype.overwriteInternalData = function (collection, primaryKey, newData) {
            var currentData = Object.assign({}, this.collections[collection].internalData[primaryKey]);
            if (currentData[primaryKey]) {
                // data already exists, merge objects and return previous object
                var keys = Object.keys(newData);
                for (var i = 0; i < keys.length; i++) {
                    var property = keys[i];
                    this.collections[collection].internalData[primaryKey][property] =
                        newData[property];
                }
                return currentData;
            }
            else {
                // data does not exist, write and return false
                this.collections[collection].internalData[primaryKey] = newData;
                return false;
            }
        };
        return Runtime;
    }());
    //# sourceMappingURL=runtime.js.map

    var Dep = /** @class */ (function () {
        function Dep(global, name, rootProperty, propertyOnObject) {
            this.global = global;
            this.name = name;
            this.rootProperty = rootProperty;
            this.propertyOnObject = propertyOnObject;
            this.dependents = new Set();
            this.subscribers = [];
        }
        Dep.prototype.register = function () {
            var subs = this.global.subs;
            if (this.global.runningComputed) {
                this.dependents.add(this.global.runningComputed);
            }
            if (subs.subscribingComponent) {
                this.subscribeComponent();
            }
            if (subs.unsubscribingComponent) ;
        };
        Dep.prototype.subscribeComponent = function () {
            var subs = this.global.subs;
            if (this.rootProperty && subs.skimmingDeepReactive) {
                subs.prepareNext(this);
                return;
            }
            if (this.rootProperty) {
                subs.foundDeepReactive();
                subs.prepareNext(this);
                return;
            }
            if (!this.rootProperty && subs.skimmingDeepReactive) {
                subs.exitDeepReactive();
            }
            this.subscribe();
            subs.prepareNext(this);
        };
        Dep.prototype.subscribe = function () {
            var subs = this.global.subs;
            var keys = subs.subscribingComponent.keys;
            var key = keys[subs.subscribingComponentKey];
            var component = {
                componentUUID: subs.subscribingComponent.componentUUID,
                key: key
            };
            this.subscribers.push(component);
        };
        return Dep;
    }());
    //# sourceMappingURL=dep.js.map

    var Reactive = /** @class */ (function () {
        function Reactive(object, global, collection, mutable, type) {
            if (object === void 0) { object = {}; }
            this.global = global;
            this.collection = collection;
            this.mutable = mutable;
            this.type = type;
            this.allowPrivateWrite = false;
            this.touching = false;
            this.dispatch = this.global.dispatch;
            this.properties = Object.keys(object);
            this.object = this.reactiveObject(object);
        }
        Reactive.prototype.reactiveObject = function (object, rootProperty) {
            var self = this;
            var objectKeys = Object.keys(object);
            var _loop_1 = function (i) {
                var key = objectKeys[i];
                var rootProperty_1 = object.rootProperty;
                var currentProperty = key;
                var value = object[key];
                // If property is an array, make it reactive
                if (Array.isArray(value)) ;
                else if (isWatchableObject(value) && !protectedNames.includes(key)) {
                    // rootProperty should be the current key if first deep object
                    value = this_1.deepReactiveObject(value, rootProperty_1 || key, currentProperty);
                }
                // Create an instance of the dependency tracker
                var dep = new Dep(this_1.global, key, rootProperty_1, currentProperty);
                Object.defineProperty(object, key, {
                    get: function pulseGetter() {
                        if (self.touching) {
                            self.touched = dep;
                            return;
                        }
                        dep.register();
                        return value;
                    },
                    set: function pulseSetter(newValue) {
                        // rootProperty indicates if the object is "deep".
                        if (rootProperty_1 && self.mutable.includes(rootProperty_1)) {
                            // mutate locally
                            value = newValue;
                            // dispatch mutation for rootProperty
                            self.dispatch('mutation', {
                                collection: self.collection,
                                key: rootProperty_1,
                                value: self.object[rootProperty_1],
                                dep: dep
                            });
                        }
                        else {
                            // if backdoor open or is protected name, allow direct mutation
                            if (self.allowPrivateWrite || protectedNames.includes(key))
                                return (value = newValue);
                            // if property is mutable dispatch update
                            if (self.mutable.includes(key)) {
                                self.dispatch('mutation', {
                                    collection: self.collection,
                                    key: key,
                                    value: newValue,
                                    dep: dep
                                });
                                // we did not apply the mutation since runtime will privatly
                                // write the result since we dispatched above
                            }
                        }
                    }
                });
            };
            var this_1 = this;
            // Loop over all properties of the to-be reactive object
            for (var i = 0; i < objectKeys.length; i++) {
                _loop_1(i);
            }
            return object;
        };
        Reactive.prototype.deepReactiveObject = function (value, rootProperty, propertyOnObject) {
            var objectWithCustomPrototype = Object.create({
                rootProperty: rootProperty,
                propertyOnObject: propertyOnObject
            });
            // repopulate custom object with incoming values
            var keys = Object.keys(value);
            for (var i = 0; i < keys.length; i++) {
                var property = keys[i];
                objectWithCustomPrototype[property] = value[property];
            }
            this.allowPrivateWrite = true;
            var obj = this.reactiveObject(objectWithCustomPrototype, rootProperty);
            this.allowPrivateWrite = false;
            return obj;
        };
        Reactive.prototype.reactiveArray = function (array, key) {
            var self = this;
            var reactiveArray = array.slice();
            var _loop_2 = function (i) {
                var func = arrayFunctions[i];
                var original = Array.prototype[func];
                Object.defineProperty(reactiveArray, func, {
                    value: function () {
                        var result = original.apply(this, arguments);
                        if (self.global.initComplete)
                            self.dispatch('mutation', {
                                collection: self.collection,
                                key: key,
                                value: result
                            });
                        return result;
                    }
                });
            };
            for (var i = 0; i < arrayFunctions.length; i++) {
                _loop_2(i);
            }
            return reactiveArray;
        };
        Reactive.prototype.privateWrite = function (property, value) {
            if (value === undefined)
                debugger;
            this.allowPrivateWrite = true;
            this.object[property] = value;
            this.allowPrivateWrite = false;
        };
        Reactive.prototype.privateGetValue = function (property) {
            return this.object[property];
        };
        Reactive.prototype.exists = function (property) {
            return !!this.object.hasOwnProperty(property);
        };
        Reactive.prototype.getDep = function (property) {
            this.touching = true;
            var _ = this.object[property]; // eslint-disable-line no-unused-var
            var dep = this.touched;
            this.touching = false;
            return dep;
        };
        return Reactive;
    }());
    // look for computed output access to determine dependencies
    // remove computed categories from public object on default config
    //# sourceMappingURL=reactive.js.map

    var Action = /** @class */ (function () {
        function Action(collection, global, action, actionName) {
            this.collection = collection;
            this.global = global;
            this.action = action;
            this.actionName = actionName;
            this.executing = false;
            this.uuid = uuid();
            this.prepare(action, global, this.global.contextRef.undo);
        }
        Action.prototype.prepare = function (action, global, undo) {
            var _this = this;
            this.exec = function () {
                var _this_1 = this;
                var context = global.getContext(_this.collection);
                context.undo = function (error) {
                    return undo(_this_1.actionName, _this_1.uuid, error);
                };
                global.runningAction = _this;
                _this.executing = true;
                var result = action.apply(null, [context].concat(Array.prototype.slice.call(arguments)));
                _this.executing = false;
                global.runningAction = false;
                return result;
            };
        };
        return Action;
    }());
    //# sourceMappingURL=action.js.map

    var Computed = /** @class */ (function () {
        function Computed(global, collection, name, computedFunction) {
            this.global = global;
            this.collection = collection;
            this.name = name;
            this.computedFunction = computedFunction;
            this.relatedToGroup = [];
            this.relatedToInternalData = [];
        }
        Computed.prototype.run = function () {
            // cleanup before running
            if (this.global.relations)
                this.global.relations.computedCleanup(this);
            this.global.runningComputed = this;
            var output = this.computedFunction(this.global.getContext(this.collection));
            if (output === undefined || output === null)
                output = false;
            this.global.runningComputed = false;
            return output;
        };
        Computed.prototype.addRelationToGroup = function (collectionName, groupName) { };
        Computed.prototype.addRelationToInternalData = function (collectionName, primaryKey) {
            // const stringified = JSON.stringify({
            //   collection: collectionName,
            //   primaryKey
            // });
            // if (!this.relatedToInternalData.includes(stringified))
            //   this.relatedToInternalData.push(stringified);
        };
        return Computed;
    }());
    //# sourceMappingURL=computed.js.map

    var Collection = /** @class */ (function () {
        function Collection(name, global, root) {
            this.name = name;
            this.global = global;
            this.config = {};
            this.keys = {};
            this.methods = {};
            this.actions = {};
            this.computed = {};
            this.watchers = {};
            this.externalWatchers = {};
            this.persist = [];
            this.local = {};
            this.collectionSize = 0;
            this.primaryKey = false;
            this.internalData = {};
            this.dataRelations = {};
            this.groupRelations = {};
            this.foreignGroupRelations = {};
            this.config = root.config;
            this.dispatch = this.global.dispatch;
            // legacy support ("filters" changed to "computed")
            root.computed = __assign({}, root.computed, root.filters);
            root = this.prepareNamespace(root);
            this.initReactive(root.data, root.groups);
            this.initRoutes(root.routes);
            this.initActions(root.actions);
            this.initWatchers(root.watch);
            this.initComputed(root.computed);
            this.initModel(root.model);
            this.initPersist(root.persist);
        }
        Collection.prototype.prepareNamespace = function (root) {
            var _this = this;
            // map collection methods
            collectionFunctions.map(function (func) { return (_this.methods[func] = _this[func].bind(_this)); });
            if (root.local)
                this.local = root.local;
            // for each type set default and register keys
            ['data', 'actions', 'computed', 'indexes', 'routes', 'watch'].forEach(function (type) {
                if (type !== 'indexes' && !root[type])
                    root[type] = {};
                _this.keys[type] =
                    type === 'indexes' ? root['groups'] || [] : Object.keys(root[type]);
            });
            // assign namespace, this is used by initReactive
            this.namespace = Object.assign(Object.create(__assign({}, this.methods)), __assign({ routes: {}, indexes: {}, actions: root.actions }, root.computed, root.data, this.normalizeGroups(root.groups)));
            return root;
        };
        // groups are defined by the user as an array of strings, this converts them into object/keys
        Collection.prototype.normalizeGroups = function (groupsAsArray) {
            if (groupsAsArray === void 0) { groupsAsArray = []; }
            var groups = {};
            for (var i = 0; i < groupsAsArray.length; i++) {
                var groupName = groupsAsArray[i];
                groups[groupName] = [];
            }
            return groups;
        };
        Collection.prototype.runWatchers = function (property) {
            var watcher = this.watchers[property];
            if (watcher)
                watcher();
            var externalWatchers = this.externalWatchers[property];
            if (externalWatchers)
                externalWatchers.forEach(function (func) {
                    return typeof func === 'function' ? func() : false;
                });
        };
        Collection.prototype.initReactive = function (data, groups) {
            if (groups === void 0) { groups = []; }
            groups = this.normalizeGroups(groups);
            // Make indexes reactive
            this.indexes = new Reactive(groups, // object
            this.global, // global
            this.name, // collection
            this.keys.indexes, // mutable
            'indexes' // type
            );
            this.namespace.indexes = this.indexes.object;
            // Make entire public object Reactive
            this.public = new Reactive(this.namespace, this.global, this.name, this.keys.data.concat(this.keys.indexes), 'root');
        };
        Collection.prototype.initPersist = function (persist) {
            var _this = this;
            if (!Array.isArray(persist))
                return;
            var _loop_1 = function (i) {
                var dataName = persist[i];
                // TODO: validate
                this_1.persist.push(dataName);
                if (this_1.global.storage.isPromise) {
                    this_1.global.storage.get(this_1.name, dataName).then(function (data) {
                        if (data === undefined || data === null)
                            return;
                        var job = {
                            type: JobType.PUBLIC_DATA_MUTATION,
                            value: data,
                            property: dataName,
                            collection: _this.name,
                            dep: _this.global.getDep(_this.name, dataName)
                        };
                        _this.global.ingest(job);
                    });
                }
                else {
                    var data = this_1.global.storage.get(this_1.name, dataName);
                    if (data === undefined || data === null)
                        return "continue";
                    this_1.public.privateWrite(dataName, data);
                }
            };
            var this_1 = this;
            for (var i = 0; i < persist.length; i++) {
                _loop_1(i);
            }
        };
        Collection.prototype.initActions = function (actions) {
            if (actions === void 0) { actions = {}; }
            var actionKeys = Object.keys(actions);
            for (var i = 0; i < actionKeys.length; i++) {
                var action = actions[actionKeys[i]];
                this.actions[actionKeys[i]] = new Action(this.name, this.global, action, actionKeys[i]);
                this.public.privateWrite(actionKeys[i], this.actions[actionKeys[i]].exec);
            }
        };
        Collection.prototype.initWatchers = function (watchers) {
            var _this = this;
            if (watchers === void 0) { watchers = {}; }
            var watcherKeys = Object.keys(watchers);
            var _loop_2 = function (i) {
                var watcher = watchers[watcherKeys[i]];
                this_2.watchers[watcherKeys[i]] = function () {
                    _this.global.runningWatcher = {
                        collection: _this.name,
                        property: watcherKeys[i]
                    };
                    var watcherOutput = watcher(_this.global.getContext(_this.name));
                    _this.global.runningWatcher = false;
                    return watcherOutput;
                };
            };
            var this_2 = this;
            for (var i = 0; i < watcherKeys.length; i++) {
                _loop_2(i);
            }
            this.watchers._keys = watcherKeys;
        };
        Collection.prototype.initComputed = function (computed) {
            var _this = this;
            objectLoop(computed, function (computedName, computedFunction) {
                _this.computed[computedName] = new Computed(_this.global, _this.name, computedName, computedFunction);
                _this.public.object[computedName] = [];
            }, this.keys.computed);
        };
        Collection.prototype.initRoutes = function (routes) {
            var _this = this;
            var self = this;
            var routeWrapped = function (routeName) {
                return function () {
                    var requestObject = Object.assign({}, self.global.request);
                    requestObject.context = self.global.getContext();
                    return routes[routeName].apply(null, [requestObject].concat(Array.prototype.slice.call(arguments)));
                };
            };
            objectLoop(routes, function (routeName) {
                return (_this.public.object.routes[routeName] = routeWrapped(routeName));
            });
        };
        Collection.prototype.initModel = function (model) {
            var _this = this;
            if (model === void 0) { model = {}; }
            Object.keys(model).forEach(function (property) {
                Object.keys(model[property]).forEach(function (config) {
                    if (config === 'primaryKey') {
                        _this.primaryKey = property;
                    }
                    else if (config === 'type') ;
                    else if (config === 'parent' || config === 'hasOne') {
                        _this.createDataRelation(property, model[property].parent || model[property].hasOne, model[property].assignTo);
                    }
                    else if (config === 'has' || config === 'hasMany') {
                        _this.createGroupRelation(property, model[property].has || model[property].hasMany, model[property].assignTo);
                    }
                });
            });
        };
        Collection.prototype.createDataRelation = function (primaryKeyName, fromCollectionName, assignTo) {
            this.dataRelations[primaryKeyName] = {};
            this.dataRelations[primaryKeyName].fromCollectionName = fromCollectionName;
            if (assignTo)
                this.dataRelations[primaryKeyName].assignTo = assignTo;
        };
        Collection.prototype.createGroupRelation = function (primaryKeyName, fromCollectionName, assignTo) {
            this.groupRelations[primaryKeyName] = {};
            this.groupRelations[primaryKeyName].fromCollectionName = fromCollectionName;
            if (assignTo)
                this.groupRelations[primaryKeyName].assignTo = assignTo;
        };
        Collection.prototype.buildGroupFromIndex = function (groupName) {
            var constructedArray = [];
            var index = this.indexes.object[groupName];
            for (var i = 0; i < index.length; i++) {
                var id = index[i];
                var data = Object.assign({}, this.internalData[id]);
                if (!data)
                    continue;
                data = this.injectDataByRelation(data);
                data = this.injectGroupByRelation(data, groupName);
                constructedArray.push(data);
            }
            return constructedArray;
        };
        Collection.prototype.injectDataByRelation = function (data) {
            // if (data.hasOwnProperty('liveStreamType')) debugger;
            var relations = Object.keys(this.dataRelations);
            if (relations.length > 0)
                for (var i = 0; i < relations.length; i++) {
                    var relationKey = relations[i]; // the key on the data to look at
                    var rel = this.dataRelations[relationKey]; // an object with fromCollectionName & assignTo
                    var assignTo = rel.hasOwnProperty('assignTo')
                        ? rel.assignTo
                        : rel.fromCollectionName;
                    if (data.hasOwnProperty(relationKey)) {
                        var foreignData = this.global.getInternalData(rel.fromCollectionName, data[relationKey]);
                        data[assignTo] = foreignData;
                    }
                }
            return data;
        };
        Collection.prototype.injectGroupByRelation = function (data, groupName) {
            var groupRealtions = Object.keys(this.groupRelations);
            if (groupRealtions.length > 0)
                for (var i = 0; i < groupRealtions.length; i++) {
                    var relationKey = groupRealtions[i];
                    var rel = this.groupRelations[relationKey];
                    var assignTo = rel.hasOwnProperty('assignTo') ? rel.assignTo : false;
                    if (data.hasOwnProperty(relationKey)) {
                        var foreignData = this.global.contextRef[rel.fromCollectionName][data[relationKey]];
                        if (foreignData) {
                            if (assignTo)
                                data[assignTo] = foreignData;
                            else
                                data[rel.fromCollectionName] = foreignData;
                        }
                        // register this relation on the foreign collection for reactive updates
                        this.global.createForeignGroupRelation(rel.fromCollectionName, data[relationKey], this.name, groupName);
                    }
                }
            return data;
        };
        Collection.prototype.createGroups = function (group) {
            if (group === undefined)
                group = [];
            else if (!Array.isArray(group))
                group = [group];
            for (var i = 0; i < group.length; i++) {
                var groupName = group[i];
                if (!this.indexes.object[groupName]) {
                    this.indexes.object[groupName] = [];
                }
            }
            return group;
        };
        // METHODS
        Collection.prototype.collect = function (data, group, config) {
            var _this = this;
            config = defineConfig(config, {
                append: true
            });
            this.global.collecting = true;
            // normalise data
            if (!Array.isArray(data))
                data = [data];
            // if groups don't already exist, create them dynamically
            var groups = this.createGroups(group);
            // groups now contains just the groups directly modified by this collect
            // preserve index previous values
            var previousIndexValues = this.getPreviousIndexValues(groups);
            var indexesToRegenOnceComplete = new Set();
            // process data items
            for (var i = 0; i < data.length; i++) {
                var dataItem = data[i];
                // process data item returns "success" as a boolean and affectedIndexes as an array
                var processDataItem = this.processDataItem(dataItem, groups, config);
                if (processDataItem.success)
                    this.collectionSize++;
                // ensure indexes modified by this data item are waiting to be ingested for regen
                processDataItem.affectedIndexes.forEach(function (index) {
                    return indexesToRegenOnceComplete.add(index);
                });
            }
            indexesToRegenOnceComplete.forEach(function (index) {
                _this.global.ingest({
                    type: JobType.INDEX_UPDATE,
                    collection: _this.name,
                    property: index,
                    value: _this.indexes.object[index],
                    previousValue: previousIndexValues[index]
                });
            });
            this.global.collecting = false;
        };
        Collection.prototype.processDataItem = function (dataItem, groups, config) {
            if (groups === void 0) { groups = []; }
            if (!this.primaryKey)
                this.findPrimaryKey(dataItem);
            var key = dataItem[this.primaryKey];
            // find affected indexes
            var affectedIndexes = groups.slice();
            this.global
                .searchIndexes(this.name, key)
                .map(function (index) { return !affectedIndexes.includes(index) && affectedIndexes.push(index); });
            // validate against model
            // ingest the data
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: this.name,
                property: key,
                value: dataItem
            });
            // add the data to group indexes
            for (var i = 0; i < groups.length; i++) {
                var groupName = groups[i];
                var index = this.indexes.object[groupName].slice();
                // remove key if already present in index
                index = index.filter(function (k) { return k !== key; });
                if (config.append)
                    index.push(key);
                else
                    index.unshift(key);
                this.indexes.privateWrite(groupName, index);
            }
            return { success: true, affectedIndexes: affectedIndexes };
        };
        Collection.prototype.getPreviousIndexValues = function (groups) {
            var returnData = {};
            for (var i = 0; i < groups; i++) {
                var groupName = groups[i];
                returnData[groupName] = this.indexes.object[groupName];
            }
            return returnData;
        };
        Collection.prototype.findPrimaryKey = function (dataItem) {
            if (dataItem.hasOwnProperty('id'))
                this.primaryKey = 'id';
            else if (dataItem.hasOwnProperty('_id'))
                this.primaryKey = '_id';
            else if (dataItem.hasOwnProperty('key'))
                this.primaryKey = 'key';
            if (this.primaryKey)
                return true;
            else
                return assert(function (warn) { return warn.NO_PRIMARY_KEY; });
        };
        Collection.prototype.replaceIndex = function (indexName, newIndex) {
            if (!Array.isArray(newIndex) || typeof indexName !== 'string')
                return assert(function (warn) { return warn.INVALID_PARAMETER; });
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: indexName,
                value: newIndex
            });
        };
        Collection.prototype.findById = function (id) {
            // if (!this.internalData.hasOwnProperty(id))
            //   return assert(warn => warn.INTERNAL_DATA_NOT_FOUND, 'findById');
            if (this.global.runningComputed) {
                var computed = this.global.runningComputed;
                this.global.relations.createInternalDataRelation(this.name, id, computed);
            }
            return this.internalData[id];
        };
        // action functions
        Collection.prototype.undo = function () { };
        Collection.prototype.throttle = function () { };
        // group functions
        Collection.prototype.move = function (ids, sourceIndexName, destIndexName, method) {
            if (method === void 0) { method = 'push'; }
            // validation
            if (!this.indexes.exists(sourceIndexName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (destIndexName && !this.indexes.exists(destIndexName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (!Array.isArray(ids))
                ids = [ids];
            var sourceIndex = this.indexes.privateGetValue(sourceIndexName);
            var _loop_3 = function (i) {
                sourceIndex.map(function (id) { return id !== ids[i]; });
            };
            for (var i = 0; i < ids.length; i++) {
                _loop_3(i);
            }
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: sourceIndexName,
                value: sourceIndex
            });
            if (destIndexName) {
                var destIndex = this.indexes.privateGetValue(destIndexName);
                for (var i = 0; i < ids.length; i++)
                    destIndex[method](ids[i]);
                this.global.ingest({
                    type: JobType.INDEX_UPDATE,
                    collection: this.name,
                    property: destIndexName,
                    value: destIndex
                });
            }
        };
        Collection.prototype.put = function (ids, destIndexName, method) {
            if (method === void 0) { method = 'push'; }
            // validation
            if (!this.indexes.exists(destIndexName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (!Array.isArray(ids))
                ids = [ids];
            var destIndex = this.indexes.privateGetValue(destIndexName);
            for (var i = 0; i < ids.length; i++)
                destIndex[method](ids[i]);
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: destIndexName,
                value: destIndex
            });
        };
        Collection.prototype.getGroup = function (property) {
            if (!this.indexes.exists(property))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; }) || [];
            if (this.global.runningComputed) {
                var computed = this.global.runningComputed;
                computed.addRelationToGroup(this.name, property);
            }
            return this.buildGroupFromIndex(property) || [];
        };
        Collection.prototype.newGroup = function (groupName, indexValue) {
            if (this.indexes.object.hasOwnProperty(groupName))
                return assert(function (warn) { return warn.GROUP_ALREADY_EXISTS; });
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: groupName,
                value: indexValue
            });
        };
        Collection.prototype.deleteGroup = function (groupName) {
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: groupName,
                value: []
            });
        };
        Collection.prototype.removeFromGroup = function (groupName, itemsToRemove) {
            if (!this.indexes.exists(groupName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (!Array.isArray(itemsToRemove))
                itemsToRemove = [itemsToRemove];
            var index = this.indexes.privateGetValue(groupName);
            var newIndex = index.filter(function (id) { return !itemsToRemove.includes(id); });
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: groupName,
                value: newIndex
            });
        };
        // internal data functions
        Collection.prototype.update = function (primaryKey, newObject) {
            if (!this.internalData.hasOwnProperty(primaryKey))
                return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; });
            var newObjectKeys = Object.keys(newObject);
            var currentData = Object.assign({}, this.internalData[primaryKey]);
            for (var i = 0; i < newObjectKeys.length; i++) {
                var key = newObjectKeys[i];
                currentData[key] = newObject[key];
            }
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: this.name,
                property: primaryKey,
                value: currentData
            });
        };
        Collection.prototype.increment = function (primaryKey, property, amount, decrement) {
            if (!this.internalData.hasOwnProperty(primaryKey))
                return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; });
            var currentData = Object.assign({}, this.internalData[primaryKey]);
            if (!validateNumber(amount, currentData[property]))
                return assert(function (warn) { return warn.PROPERTY_NOT_A_NUMBER; });
            if (decrement)
                currentData[property] -= amount;
            else
                currentData[property] += amount;
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: this.name,
                property: primaryKey,
                value: currentData
            });
        };
        Collection.prototype.decrement = function (primaryKey, property, amount) {
            this.increment(primaryKey, property, amount, true);
        };
        Collection.prototype.delete = function (primaryKeys) {
            if (!Array.isArray(primaryKeys))
                primaryKeys = [primaryKeys];
            for (var i = 0; i < primaryKeys.length; i++) {
                var primaryKey = primaryKeys[i];
                this.global.ingest({
                    type: JobType.DELETE_INTERNAL_DATA,
                    collection: this.name,
                    property: primaryKey
                });
            }
        };
        // remove all dynamic indexes, empty all indexes, delete all internal data
        Collection.prototype.purge = function () { };
        // external functions
        Collection.prototype.watch = function (property, callback) {
            if (!this.externalWatchers[property])
                this.externalWatchers[property] = [callback];
            else
                this.externalWatchers[property].push(callback);
        };
        // deprecate
        // added removeFromGroup to be more specific, params got switched around, keeping this for backwards compatibility
        Collection.prototype.remove = function (itemsToRemove, groupName) {
            return this.removeFromGroup(groupName, itemsToRemove);
        };
        return Collection;
    }());

    // This file handles external components subscribing to pulse.
    var SubController = /** @class */ (function () {
        function SubController(getContext) {
            this.getContext = getContext;
            this.uuid = uuid;
            this.subscribingComponentKey = 0;
            this.subscribingComponent = false;
            this.unsubscribingComponent = false;
            this.skimmingDeepReactive = false;
            this.lastAccessedDep = null;
            this.componentStore = {};
        }
        SubController.prototype.registerComponent = function (instance, config) {
            var uuid = instance.__pulseUniqueIdentifier;
            if (!uuid) {
                // generate UUID
                uuid = this.uuid();
                // inject uuid into component instance
                var componentContainer = {
                    instance: instance,
                    uuid: uuid,
                    ready: config.waitForMount ? false : true
                };
                instance.__pulseUniqueIdentifier = uuid;
                this.componentStore[uuid] = componentContainer;
            }
            else {
                this.mount(instance);
            }
            return uuid;
        };
        SubController.prototype.mount = function (instance) {
            var component = this.componentStore[instance.__pulseUniqueIdentifier];
            if (component) {
                component.instance = instance;
                component.ready = true;
            }
        };
        SubController.prototype.unmount = function (instance) {
            var uuid = instance.__pulseUniqueIdentifier;
            if (!uuid)
                return;
            var componentContainer = this.componentStore[instance.__pulseUniqueIdentifier];
            // delete refrence to this component from store
            delete this.componentStore[instance.__pulseUniqueIdentifier];
        };
        SubController.prototype.subscribePropertiesToComponents = function (properties, componentUUID) {
            // provisionally get keys of mapped data
            var provision = properties(this.getContext());
            var keys = Object.keys(provision);
            // mapData has a user defined local key, we need to include that in the subscription so we know what to update on the component later.
            this.subscribingComponentKey = 0;
            this.subscribingComponent = {
                componentUUID: componentUUID,
                keys: keys
            };
            var returnToComponent = properties(this.getContext());
            this.subscribingComponent = false;
            this.subscribingComponentKey = 0;
            return returnToComponent;
        };
        SubController.prototype.prepareNext = function (dep) {
            this.lastAccessedDep = dep;
            if (!this.skimmingDeepReactive)
                this.subscribingComponentKey++;
        };
        SubController.prototype.foundDeepReactive = function () {
            this.skimmingDeepReactive = true;
            // undo changes
            this.lastAccessedDep.subscribers.pop();
            this.subscribingComponentKey--;
        };
        SubController.prototype.exitDeepReactive = function () {
            this.skimmingDeepReactive = false;
            //redo changes
            this.lastAccessedDep.subscribe();
            this.subscribingComponentKey++;
        };
        return SubController;
    }());
    //# sourceMappingURL=subController.js.map

    var Storage = /** @class */ (function () {
        function Storage(storageMethods) {
            if (storageMethods === void 0) { storageMethods = {}; }
            this.storageMethods = storageMethods;
            this.isPromise = false;
            this.storageReady = false;
            this.storageType = 'localStorage';
            if (storageMethods.async)
                this.isPromise = true;
            if (this.localStorageAvaliable() && this.storageType === 'localStorage') {
                this.storageReady = true;
                storageMethods.get = localStorage.getItem.bind(localStorage);
                storageMethods.set = localStorage.setItem.bind(localStorage);
                storageMethods.remove = localStorage.removeItem.bind(localStorage);
            }
            else {
                this.storageType = 'custom';
                if (this.check(storageMethods.get) &&
                    this.check(storageMethods.set) &&
                    this.check(storageMethods.remove)) {
                    this.storageReady = true;
                }
                else {
                    this.storageReady = false;
                    // bad
                }
            }
        }
        Storage.prototype.get = function (collection, key) {
            var _this = this;
            if (!this.storageReady)
                return;
            if (this.isPromise) {
                return new Promise(function (resolve, reject) {
                    _this.storageMethods
                        .get(_this.getKey(collection, key))
                        .then(function (res) {
                        // if result is not JSON for some reason, return it.
                        if (typeof res !== 'string')
                            return resolve(res);
                        resolve(JSON.parse(res));
                    })
                        .catch(reject);
                });
            }
            else {
                return JSON.parse(this.storageMethods.get(this.getKey(collection, key)));
            }
        };
        Storage.prototype.set = function (collection, key, value) {
            if (!this.storageReady)
                return;
            this.storageMethods.set(this.getKey(collection, key), JSON.stringify(value));
        };
        Storage.prototype.remove = function (collection, key) {
            if (!this.storageReady)
                return;
            this.storageMethods.remove(this.getKey(collection, key));
        };
        Storage.prototype.getKey = function (collection, key) {
            return "_" + collection + "_" + key;
        };
        Storage.prototype.check = function (func) {
            return typeof func === 'function';
        };
        Storage.prototype.localStorageAvaliable = function () {
            try {
                localStorage.setItem('_', '_');
                localStorage.removeItem('_');
                return true;
            }
            catch (e) {
                return false;
            }
        };
        return Storage;
    }());
    //# sourceMappingURL=storage.js.map

    var Request = /** @class */ (function (_super) {
        __extends(Request, _super);
        function Request(global, requestConfig) {
            var _this = this;
            // Before we invoke the parent class, we define some defaults
            var groups = [];
            var persist = ['baseURL'];
            var data = {
                baseURL: requestConfig.baseURL || '',
                mode: 'cors',
                credentials: 'same-origin',
                headers: {
                    Accept: 'application/json'
                }
            };
            if (requestConfig.headers)
                Object.keys(requestConfig.headers).forEach(function (header) {
                    data.headers[header] = requestConfig.headers[header];
                });
            if (requestConfig.credentials)
                data.credentials = requestConfig.credentials;
            if (requestConfig.mode)
                data.mode = requestConfig.mode;
            _this = _super.call(this, 'request', global, { groups: groups, data: data, persist: persist }) || this;
            _this.requestIntercept = requestConfig.requestIntercept;
            _this.responseIntercept = requestConfig.responseIntercept;
            _this.timeout = requestConfig.timeout;
            _this.saveHistory =
                typeof requestConfig.saveHistory === 'undefined' ? true : false;
            _this.global.request = {
                get: _this.get.bind(_this),
                post: _this.post.bind(_this),
                put: _this._put.bind(_this),
                patch: _this.patch.bind(_this),
                delete: _this.delete.bind(_this),
                queryify: _this.queryify.bind(_this)
            };
            return _this;
        }
        Request.prototype.get = function (url, headers) {
            return this.send(url, 'get', {}, headers);
        };
        Request.prototype.post = function (url, body, headers) {
            return this.send(url, 'post', body, headers);
        };
        Request.prototype._put = function (url, body, headers) {
            return this.send(url, 'put', body, headers);
        };
        Request.prototype.patch = function (url, body, headers) {
            return this.send(url, 'patch', body, headers);
        };
        Request.prototype.delete = function (url, body, headers) {
            return this.send(url, 'delete', body, headers);
        };
        Request.prototype.send = function (url, method, body, headers) {
            if (body === void 0) { body = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var requestHeaders, fullURL, options, response, contentType, final, keys, i, property;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            requestHeaders = Object.assign({}, this.public.object.headers);
                            if (headers)
                                Object.keys(headers).forEach(function (header) {
                                    requestHeaders[header] = headers[header];
                                });
                            // If method is not get set application type
                            if (method !== 'get' && requestHeaders['Content-Type'] === undefined)
                                requestHeaders['Content-Type'] = 'application/json';
                            if (url.startsWith('http'))
                                fullURL = url;
                            else
                                fullURL = this.public.object.baseURL + "/" + url;
                            // Stringify body
                            body = JSON.stringify(body);
                            // Build options
                            this.options = {};
                            this.options.credentials = this.public.object.credentials;
                            this.options.mode = this.public.object.mode;
                            options = Object.assign({
                                headers: requestHeaders,
                                method: method.toUpperCase(),
                                body: method === 'get' ? null : body
                            }, this.options);
                            if (this.requestIntercept)
                                this.requestIntercept(this.global.getContext(), options);
                            if (!this.timeout) return [3 /*break*/, 2];
                            return [4 /*yield*/, Promise.race([
                                    fetch(fullURL, options),
                                    new Promise(function (resolve, reject) {
                                        return setTimeout(function () { return reject('timeout'); }, _this.timeout);
                                    })
                                ])];
                        case 1:
                            response = _a.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, fetch(fullURL, options)];
                        case 3:
                            response = _a.sent();
                            _a.label = 4;
                        case 4:
                            contentType = response.headers.get('content-type');
                            if (!(contentType && contentType.indexOf('application/json') !== -1)) return [3 /*break*/, 6];
                            return [4 /*yield*/, response.json()];
                        case 5:
                            body = _a.sent();
                            return [3 /*break*/, 8];
                        case 6: return [4 /*yield*/, response.text()];
                        case 7:
                            body = _a.sent();
                            _a.label = 8;
                        case 8:
                            // history
                            if (!this.saveHistory)
                                this.collect({
                                    id: Date.now(),
                                    status: response.status,
                                    timestamp: new Date(),
                                    response: body
                                });
                            // If reponse body is an object, create a custom object with response function in prototype, so headers and the full response data can be accessed outside of this class
                            if (!Array.isArray(body) && typeof body === 'object') {
                                final = Object.create({
                                    response: function () {
                                        return response;
                                    }
                                });
                                keys = Object.keys(body);
                                for (i = 0; i < keys.length; i++) {
                                    property = keys[i];
                                    final[property] = body[property];
                                }
                                // if the body is not an object, we can not inject a prototype, so just return the rew body
                            }
                            else {
                                final = body;
                            }
                            // intercept response
                            if (this.responseIntercept) {
                                response.data = body;
                                this.responseIntercept(this.global.getContext(), response);
                            }
                            // reject if bad response status
                            if (response.ok || response.redirected)
                                return [2 /*return*/, final];
                            // resolve response
                            throw final;
                    }
                });
            });
        };
        // Adapted from: https://github.com/Gozala/querystring/blob/master/encode.js
        Request.prototype.queryify = function (obj) {
            var stringifyPrimitive = function (value) {
                switch (typeof value) {
                    case 'string':
                        return value;
                    case 'boolean':
                        return value ? 'true' : 'false';
                    case 'number':
                        return isFinite(value) ? value : '';
                    default:
                        return '';
                }
            };
            // validate input
            if (typeof obj != 'object')
                return;
            return Object.keys(obj)
                .map(function (key) {
                var encodedKey = encodeURIComponent(stringifyPrimitive(key)) + '=';
                // if value is an array, encode with same key as parent
                if (Array.isArray(obj[key]))
                    return obj[key]
                        .map(function (value) {
                        return encodedKey + encodeURIComponent(stringifyPrimitive(value));
                    })
                        .join('&');
                // join encoded key with value
                return encodedKey + encodeURIComponent(stringifyPrimitive(obj[key]));
            })
                .join('&');
        };
        return Request;
    }(Collection));
    //# sourceMappingURL=request.js.map

    var Request$1 = /** @class */ (function (_super) {
        __extends(Request, _super);
        function Request(global, root) {
            if (root === void 0) { root = {}; }
            var _this = this;
            root = Object.assign({}, root);
            delete root.collections;
            delete root.request;
            if (!root.data)
                root.data = {};
            if (!root.persist)
                root.persist = [];
            root.data['isAuthenticated'] = false;
            root.data['appReady'] = false;
            root.persist.push('isAuthenticated');
            _this = _super.call(this, 'base', global, root) || this;
            return _this;
        }
        return Request;
    }(Collection));
    //# sourceMappingURL=base.js.map

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    var defineProperty = _defineProperty;

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }

        ownKeys.forEach(function (key) {
          defineProperty(target, key, source[key]);
        });
      }

      return target;
    }

    var objectSpread = _objectSpread;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    var classCallCheck = _classCallCheck;

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    var createClass = _createClass;

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var _typeof_1 = createCommonjsModule(function (module) {
    function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

    function _typeof(obj) {
      if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
        module.exports = _typeof = function _typeof(obj) {
          return _typeof2(obj);
        };
      } else {
        module.exports = _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };
      }

      return _typeof(obj);
    }

    module.exports = _typeof;
    });

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    var assertThisInitialized = _assertThisInitialized;

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
        return call;
      }

      return assertThisInitialized(self);
    }

    var possibleConstructorReturn = _possibleConstructorReturn;

    var getPrototypeOf = createCommonjsModule(function (module) {
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    module.exports = _getPrototypeOf;
    });

    var setPrototypeOf = createCommonjsModule(function (module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    module.exports = _setPrototypeOf;
    });

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) setPrototypeOf(subClass, superClass);
    }

    var inherits = _inherits;

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function withPulse(pulse, React, ReactComponent, selectData) {
      return (
        /*#__PURE__*/
        function (_React$Component) {
          inherits(_class, _React$Component);

          function _class(props) {
            var _this;

            classCallCheck(this, _class);

            _this = possibleConstructorReturn(this, getPrototypeOf(_class).call(this, props));
            _this.state = objectSpread({}, pulse.mapData(selectData, assertThisInitialized(_this), {
              waitForMount: pulse._private.global.config.waitForMount === false ? false : true
            }, pulse));
            return _this;
          }

          createClass(_class, [{
            key: "componentDidMount",
            value: function componentDidMount() {
              if (pulse._private.global.config.waitForMount) pulse.mount(this);
            }
          }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
              if (pulse._private.global.config.autoUnmount) pulse.unmount(this);
            }
          }, {
            key: "render",
            value: function render() {
              return React.createElement(ReactComponent, _extends({
                pulse: this.state
              }, this.props));
            }
          }]);

          return _class;
        }(React.Component)
      );
    }

    // This file tracks and handles miscellaneous relationships between:
    var RelationController = /** @class */ (function () {
        function RelationController(
        // collections reference
        global) {
            this.global = global;
            this.groupRelations = {};
            this.dataRelationsToComputed = {};
        }
        // Called inside "findById" and potentially other functions that allow data to be related to Computed properties
        RelationController.prototype.createInternalDataRelation = function (collectionName, primaryKey, computedInstance) {
            var key = collectionName + "/" + primaryKey;
            var relations = this.dataRelationsToComputed[key];
            if (Array.isArray(relations))
                relations.push(computedInstance);
            else
                this.dataRelationsToComputed[key] = [computedInstance];
        };
        // Called when internal data has been modified. It checks to see if any computed relations exist for that data.
        // If found, ingest the computed instance into the job queue.
        RelationController.prototype.internalDataModified = function (collection, primaryKey) {
            var _this = this;
            var key = collection + "/" + primaryKey;
            if (this.dataRelationsToComputed[key]) {
                this.dataRelationsToComputed[key].forEach(function (computedInstance) {
                    // ingest instance
                    _this.global.ingest({
                        type: JobType.COMPUTED_REGEN,
                        collection: collection,
                        property: computedInstance,
                        dep: _this.global.getDep(computedInstance.collection, computedInstance.name)
                    });
                });
            }
        };
        // Computed functions that include "findById" will need to cleanup their relations since output of findById (the data to relate to) has probably changed)
        RelationController.prototype.computedCleanup = function (computed) {
            var _this = this;
            var relationKeys = Object.keys(this.dataRelationsToComputed);
            var _loop_1 = function (i) {
                var relationKey = relationKeys[i];
                var relations = this_1.dataRelationsToComputed[relationKey];
                relations.forEach(function (computedInstance, index) {
                    if (computedInstance === computed) {
                        relations.length > 1
                            ? relations.splice(index, 1)
                            : delete _this.dataRelationsToComputed[relationKey];
                    }
                });
            };
            var this_1 = this;
            for (var i = 0; i < relationKeys.length; i++) {
                _loop_1(i);
            }
        };
        return RelationController;
    }());
    //# sourceMappingURL=relationController.js.map

    var Library = /** @class */ (function () {
        function Library(root) {
            var _this = this;
            // Private object contains all internal Pulse data
            this._private = {
                runtime: null,
                events: {},
                collections: {},
                collectionKeys: [],
                // global is passed in to all classes, must not contain cyclic references
                global: {
                    config: this.prepareConfig(root.config),
                    // State
                    initComplete: false,
                    runningAction: false,
                    runningWatcher: false,
                    runningComputed: false,
                    collecting: false,
                    contextRef: {},
                    // Instances
                    subs: new SubController(this.getContext.bind(this)),
                    relations: null,
                    storage: null,
                    // Function aliases
                    dispatch: this.dispatch.bind(this),
                    getInternalData: this.getInternalData.bind(this),
                    getContext: this.getContext.bind(this),
                    createForeignGroupRelation: this.createForeignGroupRelation.bind(this),
                    getDep: this.getDep.bind(this),
                    uuid: uuid
                }
            };
            // Bind static objects to instance (utils and services eventually should be initialized)
            ['utils', 'services', 'staticData'].forEach(function (type) {
                if (root[type])
                    _this[type] = root[type];
            });
            // Create storage instance
            this._private.global.storage = new Storage(root.storage);
            // Create relation controller instance
            this._private.global.relations = new RelationController(this._private.global);
            // Prepare
            this.initCollections(root);
            this.initRuntime();
            // Finalize
            this.bindCollectionPublicData();
            this.runAllComputed();
            this.initComplete();
        }
        Library.prototype.initCollections = function (root) {
            this._private.collectionKeys = Object.keys(root.collections);
            for (var i = 0; i < this._private.collectionKeys.length; i++) {
                // Create collection instance
                this._private.collections[this._private.collectionKeys[i]] = new Collection(this._private.collectionKeys[i], // name
                this._private.global, // global
                root.collections[this._private.collectionKeys[i]] // collection config
                );
            }
            // Create request class
            if (this._private.global.config.enableRequest !== false)
                this._private.collectionKeys.push('request');
            this._private.collections['request'] = new Request(this._private.global, root.request || {});
            // Create base class
            if (this._private.global.config.enableBase !== false) {
                this._private.collectionKeys.push('base');
                this._private.collections['base'] = new Request$1(this._private.global, root);
            }
        };
        Library.prototype.initRuntime = function () {
            this._private.runtime = new Runtime(this._private.collections, this._private.global);
        };
        Library.prototype.bindCollectionPublicData = function () {
            for (var i = 0; i < this._private.collectionKeys.length; i++) {
                var collection = this._private.collections[this._private.collectionKeys[i]];
                this._private.global.contextRef[this._private.collectionKeys[i]] =
                    collection.public.object;
                this[this._private.collectionKeys[i]] = collection.public.object;
            }
        };
        Library.prototype.runAllComputed = function () {
            for (var i = 0; i < this._private.collectionKeys.length; i++) {
                var collection = this._private.collections[this._private.collectionKeys[i]];
                var computedKeys = collection.keys.computed;
                for (var i_1 = 0; i_1 < computedKeys.length; i_1++) {
                    var computedName = computedKeys[i_1];
                    this._private.runtime.performComputedOutput({
                        collection: collection.name,
                        property: computedName,
                        type: JobType.COMPUTED_REGEN
                    });
                    collection.runWatchers(computedName);
                }
            }
        };
        Library.prototype.initComplete = function () {
            this._private.global.initComplete = true;
            log('INIT COMPLETE', Object.assign({}, this));
            if (!this._private.global.config.ssr) {
                try {
                    window._pulse = this;
                }
                catch (e) { }
            }
            console.log(this);
        };
        Library.prototype.wrapped = function (ReactComponent, mapData) {
            var config = this._private.global.config;
            if (config.framework === 'react' && config.frameworkConstructor) {
                return withPulse(this, config.frameworkConstructor, ReactComponent, mapData);
            }
            else
                return false;
        };
        Library.prototype.prepareConfig = function (config) {
            // defaults
            config = defineConfig(config, {
                framework: null,
                waitForMount: false,
                autoUnmount: false
            });
            // detect if framework passed in is a React constructor
            if (config.framework &&
                config.framework.hasOwnProperty('__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED')) {
                config.frameworkConstructor = config.framework;
                config.framework = 'react';
            }
            if (config.framework === 'react') {
                if (config.waitForMount != false)
                    config.waitForMount = true;
                if (config.autoUnmount != false)
                    config.autoUnmount = true;
            }
            return config;
        };
        Library.prototype.getInternalData = function (collection, primaryKey) {
            return this._private.collections[collection].findById(primaryKey);
        };
        Library.prototype.getDep = function (collection, name) {
            return this._private.collections[collection].public.getDep(name);
        };
        Library.prototype.dispatch = function (type, payload) {
            switch (type) {
                case 'mutation':
                    this._private.runtime.ingest({
                        type: JobType.PUBLIC_DATA_MUTATION,
                        collection: payload.collection,
                        property: payload.key,
                        value: payload.value,
                        dep: payload.dep
                    });
                    break;
                default:
                    break;
            }
        };
        Library.prototype.getContext = function (collection) {
            var c = this._private.collections[collection];
            if (!c)
                return this._private.global.contextRef;
            return __assign({}, this._private.global.contextRef, c.methods, { data: c.public.object, indexes: c.indexes.object, groups: c.public.object, computed: c.public.object, routes: c.public.object.routes, local: c.local });
        };
        Library.prototype.install = function (Vue) {
            this._private.global.config.framework = 'vue';
            var pulse = this;
            var config = pulse._private.global.config;
            Vue.mixin({
                beforeCreate: function () {
                    var _this = this;
                    Object.keys(pulse._private.global.contextRef).forEach(function (collection) {
                        _this['$' + collection] = pulse._private.global.contextRef[collection];
                    });
                    if (pulse.utils)
                        this.$utils = pulse.utils;
                    if (pulse.services)
                        this.$services = pulse.services;
                    if (pulse.staticData)
                        this.$staticData = pulse.staticData;
                    this.mapData = function (properties) {
                        return pulse.mapData(properties, _this, {
                            waitForMount: config.waitForMount
                        }, pulse);
                    };
                },
                mounted: function () {
                    if (this.__pulseUniqueIdentifier && config.waitForMount)
                        pulse.mount(this);
                },
                beforeDestroy: function () {
                    if (this.__pulseUniqueIdentifier && config.autoUnmount)
                        pulse.unmount(this);
                }
            });
        };
        Library.prototype.mount = function (instance) {
            this._private.global.subs.mount(instance);
        };
        Library.prototype.unmount = function (instance) {
            this._private.global.subs.unmount(instance);
        };
        Library.prototype.mapData = function (properties, instance, _config, pulseAlias) {
            if (instance === void 0) { instance = {}; }
            if (_config === void 0) { _config = {}; }
            var pulse = pulseAlias ? pulseAlias : this;
            var config = __assign({ waitForMount: true }, _config);
            var componentUUID = pulse._private.global.subs.registerComponent(instance, config);
            // new cool mapData method
            if (typeof properties === 'function') {
                return pulse._private.global.subs.subscribePropertiesToComponents(properties, componentUUID);
                // legacy support....
            }
            else if (typeof properties === 'object') {
                var returnData_1 = {};
                normalizeMap(properties).forEach(function (_a) {
                    var key = _a.key, val = _a.val;
                    var collection = val.split('/')[0];
                    var property = val.split('/')[1];
                    var c = pulse._private.global.getContext()[collection];
                    returnData_1[key] = pulse._private.global.subs.subscribePropertiesToComponents(function () {
                        var _a;
                        return _a = {}, _a[key] = c[property], _a;
                    }, componentUUID)[key];
                });
                return returnData_1;
            }
        };
        Library.prototype.createForeignGroupRelation = function (foreignCollection, foreignData, dependentCollection, dependentGroup) {
            this._private.collections[foreignCollection].foreignGroupRelations[foreignData] = {
                collection: dependentCollection,
                groupToRegen: dependentGroup
            };
        };
        Library.prototype.emit = function (name, payload) {
            if (this._private.events[name])
                for (var i = 0; i < this._private.events[name].length; i++) {
                    var callback = this._private.events[name][i];
                    callback(payload);
                }
        };
        Library.prototype.on = function (name, callback) {
            if (!Array.isArray(this._private.events[name]))
                this._private.events[name] = [callback];
            else
                this._private.events[name].push(callback);
        };
        return Library;
    }());
    //# sourceMappingURL=library.js.map

    //# sourceMappingURL=index.js.map

    return Library;

}));
//# sourceMappingURL=pulse.min.js.map
