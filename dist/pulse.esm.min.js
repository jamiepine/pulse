/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var protectedNames = [
    'data',
    'indexes',
    'groups',
    'computed',
    'actions',
    'routes'
];
var collectionFunctions = [
    'collect',
    'replaceIndex',
    'getGroup',
    'newGroup',
    'deleteGroup',
    'removeFromGroup',
    'update',
    'increment',
    'decrement',
    'delete',
    'purge',
    'watch',
    'findById',
    'put',
    'move',
    'throttle',
    'forceUpdate',
    // deprecated
    'remove'
];
function defineConfig(config, defaults) {
    return __assign({}, defaults, config);
}
function uuid() {
    return (Math.random()
        .toString()
        .split('.')[1] + Date.now());
}
function objectLoop(object, callback, keys) {
    var objectKeys = keys ? keys : Object.keys(object);
    for (var i = 0; i < objectKeys.length; i++) {
        var key_1 = objectKeys[i];
        var value = object[key_1];
        callback(key_1, value, objectKeys);
    }
}
function isWatchableObject(value) {
    function isHTMLElement(obj) {
        try {
            return obj instanceof HTMLElement;
        }
        catch (e) {
            return (typeof obj === 'object' &&
                obj.nodeType === 1 &&
                typeof obj.style === 'object' &&
                typeof obj.ownerDocument === 'object');
        }
    }
    var type = typeof value;
    return (value != null &&
        type == 'object' &&
        !isHTMLElement(value) &&
        !Array.isArray(value));
}
// const thing = {}
// objectLoop(thing, (thingKey, thingItem) => {
// })
function log(value, payload) {
    // console.log(`Pulse / ${value}`, payload ? payload : ' ');
}
function normalizeMap(map) {
    return Array.isArray(map)
        ? map.map(function (key) { return ({ key: key, val: key }); })
        : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); });
}
var arrayFunctions = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
function cleanse(object) {
    if (!isWatchableObject(object))
        return object;
    var clean = Object.assign({}, object);
    var properties = Object.keys(clean);
    for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (isWatchableObject(clean[property])) {
            clean[property] = cleanse(clean[property]);
        }
    }
    return clean;
}
function assert(func, funcName) {
    function warn(message) {
        // if (funcName) console.log(`PULSE // "${funcName}()" :: ${message}`);
        // else console.warn(`PULSE :: ${message}`);
        return false;
    }
    var warnings = {
        NO_PRIMARY_KEY: function () { return warn(); },
        INVALID_PARAMETER: function () { return warn(); },
        INDEX_NOT_FOUND: function () { return warn(); },
        INTERNAL_DATA_NOT_FOUND: function () { return warn(); },
        PROPERTY_NOT_A_NUMBER: function () { return warn(); }
    };
    return func(warnings)();
}
function validateNumber(mutable, amount) {
    if (typeof amount !== 'number' || typeof mutable !== 'number') {
        return false;
    }
    return true;
}
//# sourceMappingURL=helpers.js.map

var Dep = /** @class */ (function () {
    function Dep(global, 
    // if this dep is for public or internal data within a collection
    type, 
    // the name of the coll
    colleciton, 
    // either the name of the object if rective or the primaryKey if internal
    propertyName, 
    // if the dep is part of a deep reactive object, this is the root property name
    rootProperty) {
        if (type === void 0) { type = 'reactive'; }
        if (rootProperty === void 0) { rootProperty = null; }
        this.global = global;
        this.type = type;
        this.colleciton = colleciton;
        this.propertyName = propertyName;
        this.rootProperty = rootProperty;
        // these
        this.dependents = new Set();
        this.subscribers = [];
        // these are temporary relations created by the relation controller
        this.dynamicRelation = null;
    }
    // for when public data is accessed, reactive class will trigger this function
    Dep.prototype.register = function () {
        var subs = this.global.subs;
        if (this.global.runningComputed) {
            this.dependents.add(this.global.runningComputed);
        }
        if (this.global.runningPopulate) {
            this.global.relations.relate(this.global.runningPopulate, this);
        }
        if (subs.subscribingComponent) {
            this.subscribeComponent();
        }
        if (subs.unsubscribingComponent) ;
    };
    Dep.prototype.changed = function () {
        this.global.relations.cleanup(this.dynamicRelation);
    };
    Dep.prototype.subscribeComponent = function () {
        var subs = this.global.subs;
        if (this.rootProperty && subs.skimmingDeepReactive) {
            subs.prepareNext(this);
            return;
        }
        if (this.rootProperty) {
            subs.foundDeepReactive();
            subs.prepareNext(this);
            return;
        }
        if (!this.rootProperty && subs.skimmingDeepReactive) {
            subs.exitDeepReactive();
        }
        this.subscribe();
        subs.prepareNext(this);
    };
    Dep.prototype.subscribe = function () {
        var subs = this.global.subs;
        var keys = subs.subscribingComponent.keys;
        var key = keys[subs.subscribingComponentKey];
        var component = {
            componentUUID: subs.subscribingComponent.componentUUID,
            key: key
        };
        this.subscribers.push(component);
    };
    return Dep;
}());
//# sourceMappingURL=Dep.js.map

var Computed = /** @class */ (function () {
    function Computed(global, collection, name, computedFunction) {
        this.global = global;
        this.collection = collection;
        this.name = name;
        this.computedFunction = computedFunction;
        this.relatedToGroup = [];
        this.dynamicRelation = null;
    }
    Computed.prototype.run = function () {
        this.global.relations.cleanup(this.dynamicRelation);
        this.global.runningComputed = this;
        var output = this.computedFunction(this.global.getContext(this.collection));
        if (output === undefined || output === null)
            output = false;
        this.global.runningComputed = false;
        // haha uh oh stinky
        return output;
    };
    return Computed;
}());
// This is luka's log no. 197234 It's been 12 years, i dtil dont know the source of magnetic pull. why do rocks like stick together.. like wtf bro. for real how the fuck do magnets work
//# sourceMappingURL=computed.js.map

var DynamicRelation = /** @class */ (function () {
    function DynamicRelation(updateThis) {
        this.updateThis = updateThis;
        this.depsToClean = new Set();
    }
    // perform cleanup of all refrences to this instance
    DynamicRelation.prototype.destroy = function () {
        var _this = this;
        this.depsToClean.forEach(function (dep) { return dep.dependents.delete(_this); });
        delete this.updateThis.dynamicRelation;
    };
    return DynamicRelation;
}());
// day 652. I havent found the root cause of magnetic pull. I will have to sell my bitcoins to fund my research on the topic. fear not. the mystery of magnest WILL be solved. -luka big pants.
var RelationController = /** @class */ (function () {
    function RelationController(global) {
        this.global = global;
        this.relationBank = new Set();
    }
    // function called during runningComputed and runningPopulate
    RelationController.prototype.relate = function (updateThis, whenDepChanges) {
        if (!whenDepChanges)
            return; // if a dep is not found, abort
        var dep = whenDepChanges;
        if (!updateThis.dynamicRelation) {
            updateThis.dynamicRelation = new DynamicRelation(updateThis);
            this.relationBank.add(updateThis.dynamicRelation);
        }
        // save Dep inside relation so relation knows where to remove dependent from on cleanup
        updateThis.dynamicRelation.depsToClean.add(dep);
        // add dynamic relation as a dependent inside Dep
        dep.dependents.add(updateThis.dynamicRelation);
    };
    // when a job is complete with a dep that includes a dynamic
    RelationController.prototype.cleanup = function (dynamicRelation) {
        // perform cleanup, destroy dynamic relation
        if (!dynamicRelation)
            return;
        dynamicRelation.destroy(); // destory all refrences
        this.relationBank.delete(dynamicRelation); // remove last reference from bank
    };
    return RelationController;
}());
var RelationTypes;
(function (RelationTypes) {
    RelationTypes["COMPUTED_DEPENDS_ON_DATA"] = "COMPUTED_DEPENDS_ON_DATA";
    RelationTypes["COMPUTED_DEPENDS_ON_GROUP"] = "COMPUTED_DEPENDS_ON_GROUP";
    RelationTypes["DATA_DEPENDS_ON_DEP"] = "DATA_DEPENDS_ON_DEP";
    RelationTypes["DATA_DEPENDS_ON_GROUP"] = "DATA_DEPENDS_ON_GROUP";
    RelationTypes["DATA_DEPENDS_ON_DATA"] = "DATA_DEPENDS_ON_DATA"; // used by findById() when run in populate()
})(RelationTypes || (RelationTypes = {}));

var JobType;
(function (JobType) {
    JobType["PUBLIC_DATA_MUTATION"] = "PUBLIC_DATA_MUTATION";
    JobType["INTERNAL_DATA_MUTATION"] = "INTERNAL_DATA_MUTATION";
    JobType["INDEX_UPDATE"] = "INDEX_UPDATE";
    JobType["COMPUTED_REGEN"] = "COMPUTED_REGEN";
    JobType["GROUP_UPDATE"] = "GROUP_UPDATE";
    JobType["SOFT_GROUP_UPDATE"] = "SOFT_GROUP_UPDATE";
    JobType["DELETE_INTERNAL_DATA"] = "DELETE_INTERNAL_DATA";
})(JobType || (JobType = {}));
var Runtime = /** @class */ (function () {
    function Runtime(collections, global) {
        this.collections = collections;
        this.global = global;
        this.running = false;
        this.updatingSubscribers = false;
        this.ingestQueue = [];
        this.completedJobs = [];
        this.archivedJobs = [];
        global.ingest = this.ingest.bind(this);
        global.ingestDependents = this.ingestDependents.bind(this);
        this.config = global.config;
    }
    // The primary entry point for Runtime, all jobs should come through here
    Runtime.prototype.ingest = function (job) {
        // console.log(job);
        this.ingestQueue.push(job);
        // don't begin the next job until this one is fully complete
        if (!this.running) {
            this.findNextJob();
        }
    };
    Runtime.prototype.findNextJob = function () {
        this.running = true;
        // shift the next job from the queue
        var next = this.ingestQueue.shift();
        if (!next.dep && next.type !== JobType.INDEX_UPDATE)
            // groups, computed and indexes will not have their Dep class, so get it.
            next.dep = this.global.getDep(next.property, next.collection);
        // execute the next task in the queue
        this.performJob(next);
    };
    Runtime.prototype.performJob = function (job) {
        switch (job.type) {
            case JobType.PUBLIC_DATA_MUTATION:
                this.performPublicDataUpdate(job);
                this.collections[job.collection].runWatchers(job.property);
                break;
            case JobType.INTERNAL_DATA_MUTATION:
                this.performInternalDataUpdate(job);
                break;
            case JobType.INDEX_UPDATE:
                this.performIndexUpdate(job);
                break;
            case JobType.COMPUTED_REGEN:
                this.performComputedOutput(job);
                this.collections[job.collection].runWatchers(job.property.name);
                break;
            case JobType.GROUP_UPDATE:
                this.performGroupRebuild(job);
                this.collections[job.collection].runWatchers(job.property);
                break;
            case JobType.SOFT_GROUP_UPDATE:
                this.performGroupRebuild(job);
                this.collections[job.collection].runWatchers(job.property);
                break;
            case JobType.DELETE_INTERNAL_DATA:
                this.performInternalDataDeletion(job);
                break;
            default:
                break;
        }
        // unpack dependents
        if (job.dep && job.dep.dependents.size > 0) {
            this.ingestDependents(job.dep.dependents);
        }
        this.finished();
    };
    Runtime.prototype.ingestDependents = function (dependents) {
        var _this = this;
        // this is called twice below
        var ingestComputed = function (computed) {
            return _this.ingest({
                type: JobType.COMPUTED_REGEN,
                collection: computed.collection,
                property: computed,
                dep: _this.global.getDep(computed.name, computed.collection)
            });
        };
        // for each dependent stored in dep class
        dependents.forEach(function (dependent) {
            // there are two types of dependents stored: Computed and DynamicRelation
            if (dependent instanceof Computed)
                ingestComputed(dependent);
            else if (dependent instanceof DynamicRelation) {
                // one might think using "instanceOf" would work as expected below
                // but it doesn't, alas I hate javascript.
                // temp fix: constructor.name - be my guest try and fix this??
                var type = dependent.updateThis.constructor.name;
                // DynamicRelation can store either Computed or Dep (internal)
                if (type === Computed.name)
                    ingestComputed(dependent.updateThis);
                else if (type === Dep.name) {
                    // ingest internal data mutation without a value will result in a soft group update
                    _this.ingest({
                        type: JobType.INTERNAL_DATA_MUTATION,
                        collection: dependent.updateThis.colleciton.name,
                        property: dependent.updateThis.propertyName
                    });
                }
            }
        });
    };
    // handle job loop flow
    Runtime.prototype.finished = function () {
        var _this = this;
        this.running = false;
        if (this.completedJobs.length > 5000)
            return;
        // If there's already more stuff in the queue, loop.
        if (this.ingestQueue.length > 0) {
            this.findNextJob();
            return;
        }
        // Wait until callstack is empty to check if we should finalise this body of work
        setTimeout(function () {
            if (_this.ingestQueue.length === 0) {
                if (!_this.updatingSubscribers)
                    _this.compileComponentUpdates();
                _this.cleanup();
            }
            else {
                // loop more!
                _this.findNextJob();
            }
        });
    };
    // ****************** Perform Functions ****************** //
    Runtime.prototype.performPublicDataUpdate = function (job) {
        this.writeToPublicObject(job.collection, 'data', job.property, job.value);
        this.completedJob(job);
    };
    Runtime.prototype.performInternalDataUpdate = function (job) {
        var _this = this;
        // if job was not ingested with a value, get the most recent value from collection database
        if (!job.value) {
            if (this.collections[job.collection].internalData[job.property])
                job.value = this.collections[job.collection].internalData[job.property];
            // this would usually be redundant, since the data has not changed, but since the relationController has no access to the collections, but does need to trigger data to rebuild, it issues an internal data "update". It's own data has not changed, but the dynamic data related to it via populate() has.
        }
        // overwrite or insert the data into collection database saving the previous value to job.previousValue, since this.overwriteInternalData returns it.
        job.previousValue = this.overwriteInternalData(job.collection, job.property, job.value);
        // collection function handels ingesting indexes to update itself, since it waits until
        // all internal data has been ingested before handling the affected indexes
        // however for direct data modifications we should update afected indexes
        if (!this.global.collecting) {
            // affected indexes is an array of indexes that have this primary key (job.property) present.
            var affectedIndexes = this.collections[job.collection].searchIndexesForPrimaryKey(job.property);
            affectedIndexes.forEach(function (index) {
                // since this is a singular piece of data that has changed, we do not need to
                // rebuild the entire group, so we can soft rebuild
                var modifiedGroup = _this.collections[job.collection].softUpdateGroupData(job.property, index);
                _this.ingest({
                    type: JobType.SOFT_GROUP_UPDATE,
                    collection: job.collection,
                    value: modifiedGroup,
                    property: index,
                    dep: _this.global.getDep(index, job.collection)
                    // we do not need a previousValue because groups are cached outputs and reversing the internal data update will do the trick
                });
            });
        }
        this.completedJob(job);
    };
    Runtime.prototype.performInternalDataDeletion = function (job) {
        var c = this.collections[job.collection];
        // preserve previous value
        job.previousValue = __assign({}, c.internalData[job.property]);
        // delete data
        delete c.internalData[job.property];
        // find indexes affected by this data deletion
        var indexesToUpdate = this.collections[job.collection].searchIndexesForPrimaryKey(job.collection, job.property);
        // for each found index, perform index update
        for (var i = 0; i < indexesToUpdate.length; i++) {
            var indexName = indexesToUpdate[i];
            var newIndex = c.indexes.object[indexName].slice().filter(function (id) { return id !== job.property; });
            this.ingest({
                type: JobType.INDEX_UPDATE,
                collection: c.name,
                property: indexName,
                value: newIndex,
                dep: this.global.getDep(job.property, job.collection)
            });
        }
        this.completedJob(job);
    };
    Runtime.prototype.performIndexUpdate = function (job) {
        // preserve old index
        job.previousValue = this.collections[job.collection].indexes[job.property];
        // Update Index
        this.collections[job.collection].indexes.privateWrite(job.property, job.value);
        this.completedJob(job);
        // Group must also be updated
        this.ingest({
            type: JobType.GROUP_UPDATE,
            collection: job.collection,
            property: job.property,
            dep: this.global.getDep(job.property, job.collection)
        });
    };
    Runtime.prototype.performGroupRebuild = function (job) {
        // soft group rebuilds already have a generated value, otherwise generate the value
        if (!job.value) {
            job.value = this.collections[job.collection].buildGroupFromIndex(job.property);
        }
        // TODO: trigger relaction controller to update group relations
        // this.global.relations.groupModified(job.collection, job.property);
        this.writeToPublicObject(job.collection, 'group', job.property, job.value);
        this.completedJob(job);
    };
    Runtime.prototype.performComputedOutput = function (job) {
        var computed = typeof job.property === 'string'
            ? this.collections[job.collection].computed[job.property]
            : job.property;
        job.value = computed.run();
        // Commit Update
        this.writeToPublicObject(job.collection, 'computed', computed.name, job.value);
        this.completedJob(job);
    };
    // ****************** Handlers ****************** //
    Runtime.prototype.completedJob = function (job) {
        // if action is running, save that action instance inside job payload
        job.fromAction = this.global.runningAction;
        // during runtime log completed job ready for component updates
        if (this.global.initComplete)
            this.completedJobs.push(job);
        // if data is persistable ensure storage is updated with new data
        this.persistData(job);
        // tell the dep the parent changed
        if (job.dep)
            job.dep.changed();
    };
    // ****************** End Runtime Events ****************** //
    Runtime.prototype.compileComponentUpdates = function () {
        if (!this.global.initComplete)
            return;
        this.updatingSubscribers = true;
        log('ALL JOBS COMPLETE', this.completedJobs);
        var componentsToUpdate = {};
        // for all completed jobs
        for (var i = 0; i < this.completedJobs.length; i++) {
            var job = this.completedJobs[i];
            // if job has a Dep class present
            // Dep class contains subscribers to that property (as a completed job)
            if (job.dep) {
                var subscribers = job.dep.subscribers;
                // for all the subscribers
                for (var i_1 = 0; i_1 < subscribers.length; i_1++) {
                    // add to componentsToUpdate (ensuring update & component is unique)
                    var uuid = subscribers[i_1].componentUUID;
                    var key = subscribers[i_1].key;
                    // below is a band-aid, caused by (what I believe to be) deep reactive properties submitting several updates for the same mutation, one for each level deep, since the parent is triggered as well
                    // if (!key) continue;
                    // if this component isn't already registered for this particular update, add it.
                    if (!componentsToUpdate[uuid]) {
                        componentsToUpdate[uuid] = {};
                        componentsToUpdate[uuid][key] = job.value;
                        // otherwise add the update to the component
                    }
                    else {
                        componentsToUpdate[uuid][key] = job.value;
                    }
                }
            }
        }
        this.updateSubscribers(componentsToUpdate);
        this.completedJobs = [];
    };
    Runtime.prototype.updateSubscribers = function (componentsToUpdate) {
        // console.log('updating subscribers', componentsToUpdate);
        var componentKeys = Object.keys(componentsToUpdate);
        var _loop_1 = function (i) {
            var componentID = componentKeys[i];
            var componentInstance = this_1.global.subs.componentStore[componentID];
            if (!componentInstance || !componentInstance.instance)
                return { value: void 0 };
            var propertiesToUpdate = componentsToUpdate[componentID];
            var dataKeys = Object.keys(propertiesToUpdate);
            // Switch depending on framework
            switch (this_1.global.config.framework) {
                case 'vue':
                    dataKeys.forEach(function (property) {
                        var value = propertiesToUpdate[property];
                        componentInstance.instance.$set(componentInstance.instance, property, 
                        // this prevents vue from adding getters/setters to any objects, but might be wasteful computation
                        // considering this is not important and does not change perfomance, its probably best to not bother cleansing every
                        // value update. actually thinking about it this is terrbile. remove this soon.
                        // honestly it's only here because I have OCD.
                        cleanse(value));
                    });
                    break;
                case 'react':
                    componentInstance.instance.setState(propertiesToUpdate);
                    // console.log(propertiesToUpdate);
                    break;
                default:
                    break;
            }
        };
        var this_1 = this;
        for (var i = 0; i < componentKeys.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    };
    Runtime.prototype.persistData = function (job) {
        if (job.type === JobType.INTERNAL_DATA_MUTATION)
            return;
        if (this.collections[job.collection].persist.includes(job.property)) {
            this.global.storage.set(job.collection, job.property, job.value);
        }
    };
    Runtime.prototype.cleanup = function () {
        var _this = this;
        setTimeout(function () {
            _this.updatingSubscribers = false;
        });
    };
    // ****************** Misc Handlers ****************** //
    Runtime.prototype.writeToPublicObject = function (collection, type, key, value) {
        if (type === 'indexes') {
            if (!this.collections[collection][type].object.hasOwnProperty(key))
                return;
            this.collections[collection][type].privateWrite(key, value);
        }
        else {
            if (!this.collections[collection].public.object.hasOwnProperty(key))
                return;
            this.collections[collection].public.privateWrite(key, value);
        }
    };
    Runtime.prototype.overwriteInternalData = function (collection, primaryKey, newData) {
        var internalData = this.collections[collection].internalData;
        // create a copy of the original data
        var currentData = internalData[primaryKey]
            ? __assign({}, internalData[primaryKey]) : false;
        if (currentData) {
            // data already exists, merge objects and return previous object
            var keys = Object.keys(newData || {});
            for (var i = 0; i < keys.length; i++) {
                var property = keys[i];
                internalData[primaryKey][property] = newData[property];
            }
            return currentData;
        }
        else {
            // data does not exist, write and return false
            internalData[primaryKey] = newData;
            return false;
        }
    };
    return Runtime;
}());
//# sourceMappingURL=runtime.js.map

var Dep$1 = /** @class */ (function () {
    function Dep(global, 
    // if this dep is for public or internal data within a collection
    type, 
    // the name of the coll
    colleciton, 
    // either the name of the object if rective or the primaryKey if internal
    propertyName, 
    // if the dep is part of a deep reactive object, this is the root property name
    rootProperty) {
        if (type === void 0) { type = 'reactive'; }
        if (rootProperty === void 0) { rootProperty = null; }
        this.global = global;
        this.type = type;
        this.colleciton = colleciton;
        this.propertyName = propertyName;
        this.rootProperty = rootProperty;
        // these
        this.dependents = new Set();
        this.subscribers = [];
        // these are temporary relations created by the relation controller
        this.dynamicRelation = null;
    }
    // for when public data is accessed, reactive class will trigger this function
    Dep.prototype.register = function () {
        var subs = this.global.subs;
        if (this.global.runningComputed) {
            this.dependents.add(this.global.runningComputed);
        }
        if (this.global.runningPopulate) {
            this.global.relations.relate(this.global.runningPopulate, this);
        }
        if (subs.subscribingComponent) {
            this.subscribeComponent();
        }
        if (subs.unsubscribingComponent) ;
    };
    Dep.prototype.changed = function () {
        this.global.relations.cleanup(this.dynamicRelation);
    };
    Dep.prototype.subscribeComponent = function () {
        var subs = this.global.subs;
        if (this.rootProperty && subs.skimmingDeepReactive) {
            subs.prepareNext(this);
            return;
        }
        if (this.rootProperty) {
            subs.foundDeepReactive();
            subs.prepareNext(this);
            return;
        }
        if (!this.rootProperty && subs.skimmingDeepReactive) {
            subs.exitDeepReactive();
        }
        this.subscribe();
        subs.prepareNext(this);
    };
    Dep.prototype.subscribe = function () {
        var subs = this.global.subs;
        var keys = subs.subscribingComponent.keys;
        var key = keys[subs.subscribingComponentKey];
        var component = {
            componentUUID: subs.subscribingComponent.componentUUID,
            key: key
        };
        this.subscribers.push(component);
    };
    return Dep;
}());
//# sourceMappingURL=dep.js.map

var Reactive = /** @class */ (function () {
    function Reactive(object, global, collection, mutable, type) {
        if (object === void 0) { object = {}; }
        this.global = global;
        this.collection = collection;
        this.mutable = mutable;
        this.type = type;
        this.allowPrivateWrite = false;
        this.touching = false;
        this.tempDeps = {};
        this.dispatch = this.global.dispatch;
        this.properties = Object.keys(object);
        this.object = this.reactiveObject(object);
    }
    Reactive.prototype.reactiveObject = function (object, rootProperty) {
        var objectKeys = Object.keys(object);
        // Loop over all properties of the to-be reactive object
        for (var i = 0; i < objectKeys.length; i++) {
            var key = objectKeys[i];
            this.defineProperty(object, key, rootProperty);
        }
        return object;
    };
    Reactive.prototype.defineProperty = function (object, key, rootProperty) {
        var self = this;
        var value = object[key];
        if (object.rootProperty)
            rootProperty = object.rootProperty;
        // // If property is an array, make it reactive
        // if (Array.isArray(value)) {
        //   // value = this.reactiveArray(value, key);
        // }
        // rootProperty should be the current key if first deep object
        if (isWatchableObject(value) && !protectedNames.includes(key)) {
            value = this.deepReactiveObject(value, rootProperty || key, key);
        }
        // Create an instance of the dependency tracker
        var dep = this.createDep(key, rootProperty);
        Object.defineProperty(object, key, {
            get: function pulseGetter() {
                if (self.sneaky)
                    return value;
                if (self.global.touching) {
                    self.global.touched = dep;
                    return value;
                }
                dep.register();
                return value;
            },
            set: function pulseSetter(newValue) {
                // DEEP REACTIVE handler: "rootProperty" indicates if the object is "deep".
                if (rootProperty && self.mutable.includes(rootProperty)) {
                    // mutate locally
                    value = newValue;
                    // dispatch mutation for deep property
                    self.dispatch('mutation', {
                        collection: self.collection.name,
                        key: rootProperty,
                        value: self.object[rootProperty],
                        dep: dep
                    });
                    // Regular muations
                }
                else {
                    // if a protected name allow direct mutation
                    if (protectedNames.includes(key)) {
                        return (value = newValue);
                    }
                    // if backdoor open allow direct mutation
                    if (self.allowPrivateWrite) {
                        // dynamically convert new values to reactive if objects
                        // This is risky as fuck and kinda doesn't even work
                        if (isWatchableObject(value) && self.mutable.includes(key)) {
                            // debugger;
                            newValue = self.deepReactiveObject(newValue, rootProperty || key, key);
                        }
                        return (value = newValue);
                    }
                    // if property is mutable dispatch update
                    if (self.mutable.includes(key)) {
                        self.dispatch('mutation', {
                            collection: self.collection.name,
                            key: key,
                            value: newValue,
                            dep: dep
                        });
                        // we did not apply the mutation since runtime will privatly
                        // write the result since we dispatched above
                    }
                }
            }
        });
        return object;
    };
    Reactive.prototype.addProperty = function (key, value) {
        this.object[key] = value;
        this.defineProperty(this.object, key);
    };
    Reactive.prototype.tempDep = function (property) {
        var dep = this.createDep(property);
        this.tempDeps[property] = dep;
        return dep;
    };
    Reactive.prototype.cloneDep = function (dep) {
        dep = Object.assign(Object.create(Object.getPrototypeOf(dep)), dep);
        // debugger;
        // delete this.tempDeps[dep.propertyName];
        return dep;
    };
    Reactive.prototype.createDep = function (key, rootProperty) {
        var dep;
        if (this.tempDeps.hasOwnProperty(key) && !rootProperty) {
            dep = this.cloneDep(this.tempDeps[key]);
        }
        else {
            dep = new Dep$1(this.global, this.type === 'indexes' ? 'index' : 'reactive', this.collection, key, rootProperty);
        }
        return dep;
    };
    Reactive.prototype.deepReactiveObject = function (value, rootProperty, propertyName) {
        var objectWithCustomPrototype = Object.create({
            rootProperty: rootProperty,
            propertyName: propertyName
        });
        // repopulate custom object with incoming values
        var keys = Object.keys(value);
        for (var i = 0; i < keys.length; i++) {
            var property = keys[i];
            objectWithCustomPrototype[property] = value[property];
        }
        this.allowPrivateWrite = true;
        var obj = this.reactiveObject(objectWithCustomPrototype, rootProperty);
        this.allowPrivateWrite = false;
        return obj;
    };
    Reactive.prototype.reactiveArray = function (array, key) {
        var self = this;
        var reactiveArray = array.slice();
        var _loop_1 = function (i) {
            var func = arrayFunctions[i];
            var original = Array.prototype[func];
            Object.defineProperty(reactiveArray, func, {
                value: function () {
                    var result = original.apply(this, arguments);
                    if (self.global.initComplete)
                        self.dispatch('mutation', {
                            collection: self.collection.name,
                            key: key,
                            value: result
                        });
                    return result;
                }
            });
        };
        for (var i = 0; i < arrayFunctions.length; i++) {
            _loop_1(i);
        }
        return reactiveArray;
    };
    Reactive.prototype.privateWrite = function (property, value) {
        this.allowPrivateWrite = true;
        this.object[property] = value;
        this.allowPrivateWrite = false;
    };
    // sneaky blocked the getter, sneaky.
    Reactive.prototype.privateGet = function (property) {
        this.sneaky = true;
        var data = this.object[property];
        this.sneaky = false;
        return data;
    };
    Reactive.prototype.exists = function (property) {
        this.sneaky = true;
        var bool = !!this.object.hasOwnProperty(property);
        this.sneaky = false;
        return bool;
    };
    Reactive.prototype.getKeys = function () {
        this.sneaky = true;
        var keys = Object.keys(this.object);
        this.sneaky = false;
        return keys;
    };
    return Reactive;
}());
// look for computed output access to determine dependencies
// remove computed categories from public object on default config
//# sourceMappingURL=reactive.js.map

var Action = /** @class */ (function () {
    function Action(collection, global, action, actionName) {
        this.collection = collection;
        this.global = global;
        this.action = action;
        this.actionName = actionName;
        this.executing = false;
        this.uuid = uuid();
        this.prepare(action, global, this.global.contextRef.undo);
    }
    Action.prototype.prepare = function (action, global, undo) {
        var _this = this;
        this.exec = function () {
            var _this_1 = this;
            var context = global.getContext(_this.collection);
            context.undo = function (error) {
                return undo(_this_1.actionName, _this_1.uuid, error);
            };
            global.runningAction = _this;
            _this.executing = true;
            var result = action.apply(null, [context].concat(Array.prototype.slice.call(arguments)));
            _this.executing = false;
            global.runningAction = false;
            return result;
        };
    };
    return Action;
}());
//# sourceMappingURL=action.js.map

var Collection = /** @class */ (function () {
    function Collection(name, global, root) {
        this.name = name;
        this.global = global;
        this.config = {};
        this.keys = {};
        this.methods = {};
        this.actions = {};
        this.computed = {};
        this.watchers = {};
        this.externalWatchers = {};
        this.persist = [];
        this.local = {};
        this.model = {};
        this.collectionSize = 0;
        this.primaryKey = false;
        this.internalData = {};
        this.internalDataDeps = {}; // this contains the dep classes for all internal data
        this.internalDataWithPopulate = [];
        this.config = root.config;
        this.dispatch = this.global.dispatch;
        // legacy support ("filters" changed to "computed")
        root.computed = __assign({}, root.computed, root.filters);
        root = this.prepareNamespace(root);
        this.initReactive(root.data, root.groups);
        this.initRoutes(root.routes);
        this.initActions(root.actions);
        this.initWatchers(root.watch);
        this.initComputed(root.computed);
        this.initModel(root.model);
        this.initPersist(root.persist);
    }
    Collection.prototype.prepareNamespace = function (root) {
        var _this = this;
        // map collection methods
        collectionFunctions.map(function (func) { return (_this.methods[func] = _this[func].bind(_this)); });
        if (root.local)
            this.local = root.local;
        // for each type set default and register keys
        ['data', 'actions', 'computed', 'indexes', 'routes', 'watch'].forEach(function (type) {
            if (type !== 'indexes' && !root[type])
                root[type] = {};
            _this.keys[type] =
                type === 'indexes' ? root['groups'] || [] : Object.keys(root[type]);
        });
        // assign namespace, this is used by initReactive
        this.namespace = Object.assign(Object.create(__assign({}, this.methods)), __assign({ routes: {}, indexes: {}, actions: root.actions }, root.computed, root.data, this.normalizeGroups(root.groups)));
        return root;
    };
    // groups are defined by the user as an array of strings, this converts them into object/keys
    Collection.prototype.normalizeGroups = function (groupsAsArray) {
        if (groupsAsArray === void 0) { groupsAsArray = []; }
        var groups = {};
        for (var i = 0; i < groupsAsArray.length; i++) {
            var groupName = groupsAsArray[i];
            groups[groupName] = [];
        }
        return groups;
    };
    Collection.prototype.runWatchers = function (property) {
        var watcher = this.watchers[property];
        if (watcher)
            watcher();
        var externalWatchers = this.externalWatchers[property];
        if (externalWatchers)
            externalWatchers.forEach(function (func) {
                return typeof func === 'function' ? func() : false;
            });
    };
    Collection.prototype.initReactive = function (data, groups) {
        if (groups === void 0) { groups = []; }
        groups = this.normalizeGroups(groups);
        // Make indexes reactive
        this.indexes = new Reactive(groups, // object
        this.global, // global
        this, // collection
        this.keys.indexes, // mutable
        'indexes' // type
        );
        this.namespace.indexes = this.indexes.object;
        // Make entire public object Reactive
        this.public = new Reactive(this.namespace, this.global, this, this.keys.data.concat(this.keys.indexes), 'root');
    };
    Collection.prototype.initPersist = function (persist) {
        var _this = this;
        if (!Array.isArray(persist))
            return;
        var _loop_1 = function (i) {
            var dataName = persist[i];
            // TODO: validate
            this_1.persist.push(dataName);
            if (this_1.global.storage.isPromise) {
                this_1.global.storage.get(this_1.name, dataName).then(function (data) {
                    if (data === undefined || data === null)
                        return;
                    var job = {
                        type: JobType.PUBLIC_DATA_MUTATION,
                        value: data,
                        property: dataName,
                        collection: _this.name,
                        dep: _this.global.getDep(dataName, _this.name)
                    };
                    _this.global.ingest(job);
                });
            }
            else {
                var data = this_1.global.storage.get(this_1.name, dataName);
                if (data === undefined || data === null)
                    return "continue";
                this_1.public.privateWrite(dataName, data);
            }
        };
        var this_1 = this;
        for (var i = 0; i < persist.length; i++) {
            _loop_1(i);
        }
    };
    Collection.prototype.initActions = function (actions) {
        if (actions === void 0) { actions = {}; }
        var actionKeys = Object.keys(actions);
        for (var i = 0; i < actionKeys.length; i++) {
            var action = actions[actionKeys[i]];
            this.actions[actionKeys[i]] = new Action(this.name, this.global, action, actionKeys[i]);
            this.public.privateWrite(actionKeys[i], this.actions[actionKeys[i]].exec);
        }
    };
    Collection.prototype.initWatchers = function (watchers) {
        var _this = this;
        if (watchers === void 0) { watchers = {}; }
        var watcherKeys = Object.keys(watchers);
        var _loop_2 = function (i) {
            var watcher = watchers[watcherKeys[i]];
            this_2.watchers[watcherKeys[i]] = function () {
                _this.global.runningWatcher = {
                    collection: _this.name,
                    property: watcherKeys[i]
                };
                var watcherOutput = watcher(_this.global.getContext(_this.name));
                _this.global.runningWatcher = false;
                return watcherOutput;
            };
        };
        var this_2 = this;
        for (var i = 0; i < watcherKeys.length; i++) {
            _loop_2(i);
        }
        this.watchers._keys = watcherKeys;
    };
    Collection.prototype.initComputed = function (computed) {
        var _this = this;
        objectLoop(computed, function (computedName, computedFunction) {
            _this.computed[computedName] = new Computed(_this.global, _this.name, computedName, computedFunction);
            _this.public.object[computedName] = [];
        }, this.keys.computed);
    };
    Collection.prototype.initRoutes = function (routes) {
        var _this = this;
        var self = this;
        var routeWrapped = function (routeName) {
            return function () {
                var requestObject = Object.assign({}, self.global.request);
                requestObject.context = self.global.getContext();
                return routes[routeName].apply(null, [requestObject].concat(Array.prototype.slice.call(arguments)));
            };
        };
        objectLoop(routes, function (routeName) {
            return (_this.public.object.routes[routeName] = routeWrapped(routeName));
        });
    };
    Collection.prototype.initModel = function (model) {
        var _this = this;
        if (model === void 0) { model = {}; }
        this.model = model;
        Object.keys(model).forEach(function (property) {
            Object.keys(model[property]).forEach(function (config) {
                switch (config) {
                    case 'primaryKey':
                        _this.primaryKey = property;
                        break;
                    case 'populate':
                        _this.internalDataWithPopulate.push(property);
                        break;
                }
            });
        });
    };
    Collection.prototype.getData = function (id) {
        return __assign({}, this.internalData[id]);
    };
    Collection.prototype.buildGroupFromIndex = function (groupName) {
        var constructedArray = [];
        // get index directly
        var index = this.indexes.privateGet(groupName);
        if (!index)
            return [];
        // for every primaryKey in the index
        for (var i = 0; i < index.length; i++) {
            // primaryKey of data
            var id = index[i];
            // copy data from internal database
            var data = this.getData(id);
            // if none found skip
            if (!data)
                continue;
            // inject dynamic data
            data = this.injectDynamicRelatedData(id, data);
            constructedArray.push(data);
        }
        return constructedArray;
    };
    // rebuilding an entire group is expensive on resources, but is
    // not nessisary if only one piece of data has changed
    // this function will replace a single piece of data without rebuilding
    // the entire group
    Collection.prototype.softUpdateGroupData = function (primaryKey, groupName) {
        var index = this.indexes.privateGet(groupName);
        // find the data's position within index
        var position = index.indexOf(primaryKey);
        // if group is dynamic, just build the group from index.
        if (!this.public[groupName])
            return this.buildGroupFromIndex(groupName);
        // copy the current group output
        var currentGroup = [this.public[groupName]];
        // get data for primaryKey
        var data = __assign({}, this.internalData[primaryKey]);
        data = this.injectDynamicRelatedData(primaryKey, data);
        // replace at known position with updated data
        currentGroup[position] = data;
        return currentGroup;
    };
    // This should be called on every piece of data retrieved when building a group from an index
    Collection.prototype.injectDynamicRelatedData = function (primaryKey, data) {
        var _this = this;
        // for each populate function extracted from the model for this data
        this.internalDataWithPopulate.forEach(function (property) {
            var dep = _this.global.getDep(primaryKey, _this.name, true);
            _this.global.runningPopulate = dep;
            // run populate function passing in the context and the data
            var populated = _this.model[property].populate(_this.global.getContext(), data);
            _this.global.runningPopulate = false;
            // inject result to data
            data[property] = populated;
        });
        return data;
    };
    Collection.prototype.createGroups = function (group) {
        if (group === undefined)
            group = [];
        else if (!Array.isArray(group))
            group = [group];
        for (var i = 0; i < group.length; i++) {
            var groupName = group[i];
            if (!this.indexes.exists(groupName)) {
                this.indexes.addProperty(groupName, []);
                // this.indexes.privateWrite(groupName, []);
            }
        }
        return group;
    };
    // METHODS
    Collection.prototype.collect = function (data, group, config) {
        var _this = this;
        config = defineConfig(config, {
            append: true
        });
        this.global.collecting = true;
        // normalise data
        if (!Array.isArray(data))
            data = [data];
        // if groups don't already exist, create them dynamically
        var groups = this.createGroups(group);
        // groups now contains just the groups directly modified by this collect
        // preserve index previous values
        var previousIndexValues = this.getPreviousIndexValues(groups);
        var indexesToRegenOnceComplete = new Set();
        // process data items
        for (var i = 0; i < data.length; i++) {
            var dataItem = data[i];
            if (dataItem === null)
                continue;
            // process data item returns "success" as a boolean and affectedIndexes as an array
            var processDataItem = this.processDataItem(dataItem, groups, config);
            if (!processDataItem)
                continue;
            if (processDataItem.success)
                this.collectionSize++;
            // ensure indexes modified by this data item are waiting to be ingested for regen
            processDataItem.affectedIndexes.forEach(function (index) {
                return indexesToRegenOnceComplete.add(index);
            });
        }
        indexesToRegenOnceComplete.forEach(function (index) {
            _this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: _this.name,
                property: index,
                value: _this.indexes.privateGet(index),
                previousValue: previousIndexValues[index],
                dep: _this.global.getDep(index, _this.indexes.object)
            });
        });
        this.global.collecting = false;
    };
    Collection.prototype.processDataItem = function (dataItem, groups, config) {
        if (groups === void 0) { groups = []; }
        if (!this.primaryKey)
            this.findPrimaryKey(dataItem);
        if (!this.primaryKey)
            return false;
        var key = dataItem[this.primaryKey];
        // find affected indexes
        var affectedIndexes = groups.slice();
        // searchIndexesForPrimaryKey returns an array of indexes that include that primaryKey
        // for each index found, if it is not already known, add to affected indexes
        this.searchIndexesForPrimaryKey(key).map(function (index) { return !affectedIndexes.includes(index) && affectedIndexes.push(index); });
        // validate against model
        // create the dep class
        if (!this.internalDataDeps[key])
            this.internalDataDeps[key] = new Dep$1(this.global, 'internal', this, key);
        // ingest the data
        this.global.ingest({
            type: JobType.INTERNAL_DATA_MUTATION,
            collection: this.name,
            property: key,
            value: dataItem,
            dep: this.internalDataDeps[key]
        });
        // add the data to group indexes
        for (var i = 0; i < groups.length; i++) {
            var groupName = groups[i];
            var index = this.indexes.privateGet(groupName);
            // remove key if already present in index
            index = index.filter(function (k) { return k != key; });
            if (config.append)
                index.push(key);
            else
                index.unshift(key);
            // write index
            this.indexes.privateWrite(groupName, index);
        }
        return { success: true, affectedIndexes: affectedIndexes };
    };
    Collection.prototype.searchIndexesForPrimaryKey = function (primaryKey) {
        // get a fresh copy of the keys to include dynamic indexes
        var keys = this.indexes.getKeys();
        var foundIndexes = [];
        // for every index
        for (var i = 0; i < keys.length; i++) {
            var indexName = keys[i];
            // if the index includes the primaryKey
            if (this.indexes.privateGet(indexName).includes(primaryKey))
                foundIndexes.push(indexName);
        }
        return foundIndexes;
    };
    Collection.prototype.getPreviousIndexValues = function (groups) {
        var returnData = {};
        for (var i = 0; i < groups; i++) {
            var groupName = groups[i];
            returnData[groupName] = this.indexes.privateGet(groupName);
        }
        return returnData;
    };
    Collection.prototype.findPrimaryKey = function (dataItem) {
        if (dataItem.hasOwnProperty('id'))
            this.primaryKey = 'id';
        else if (dataItem.hasOwnProperty('_id'))
            this.primaryKey = '_id';
        else if (dataItem.hasOwnProperty('key'))
            this.primaryKey = 'key';
        if (this.primaryKey)
            return true;
        else
            return assert(function (warn) { return warn.NO_PRIMARY_KEY; });
    };
    Collection.prototype.replaceIndex = function (indexName, newIndex) {
        if (!Array.isArray(newIndex) || typeof indexName !== 'string')
            return assert(function (warn) { return warn.INVALID_PARAMETER; });
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: indexName,
            value: newIndex
        });
    };
    // if a computed function evaluates and creates a relation to internal data
    // that does not exist yet, we create the dep class and save it in advance
    // so that if the data ever arrives, it will reactively dependent update accordingly
    Collection.prototype.depForInternalData = function (primaryKey) {
        var dep;
        // debugger;
        if (!this.internalDataDeps[primaryKey]) {
            dep = new Dep$1(this.global, 'internal', this, primaryKey);
            this.internalDataDeps[primaryKey] = dep;
        }
        else {
            dep = this.internalDataDeps[primaryKey];
        }
        return dep;
    };
    //
    Collection.prototype.depForGroup = function (groupName) {
        var dep;
        // no group is found publically, use index instead
        if (this.public.exists(groupName)) {
            dep = this.global.getDep(groupName, this.name);
        }
        else if (this.indexes.exists(groupName)) {
            dep = this.global.getDep(groupName, this.indexes.object);
        }
        else {
            dep = this.indexes.tempDep(groupName);
        }
        return dep;
    };
    Collection.prototype.findById = function (id) {
        var internalDep = this.depForInternalData(id);
        if (this.global.runningComputed) {
            var computed = this.global.runningComputed;
            this.global.relations.relate(computed, internalDep);
        }
        if (this.global.runningPopulate) {
            var populate = this.global.runningPopulate;
            this.global.relations.relate(populate, internalDep);
        }
        return this.internalData[id];
    };
    Collection.prototype.getGroup = function (property) {
        var groupDep = this.depForGroup(property);
        // if called inside Computed method, create temporary relation in relationship controller
        if (this.global.runningComputed) {
            var computed = this.global.runningComputed;
            this.global.relations.relate(computed, groupDep);
        }
        // if called from within populate() create another temporary relation
        if (this.global.runningPopulate) {
            var dataDep = this.global.runningPopulate;
            this.global.relations.relate(dataDep, groupDep);
        }
        // get group is not cached, so generate a fresh group from the index
        return this.buildGroupFromIndex(property) || [];
    };
    // action functions
    Collection.prototype.undo = function () { };
    Collection.prototype.throttle = function () { };
    // group functions
    Collection.prototype.move = function (ids, sourceIndexName, destIndexName, method) {
        if (method === void 0) { method = 'push'; }
        // validation
        if (!this.indexes.exists(sourceIndexName))
            return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
        if (destIndexName && !this.indexes.exists(destIndexName))
            return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
        if (!Array.isArray(ids))
            ids = [ids];
        var sourceIndex = this.indexes.privateGet(sourceIndexName);
        var _loop_3 = function (i) {
            sourceIndex = sourceIndex.filter(function (id) { return id !== ids[i]; });
        };
        for (var i = 0; i < ids.length; i++) {
            _loop_3(i);
        }
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: sourceIndexName,
            value: sourceIndex
        });
        if (destIndexName) {
            var destIndex = this.indexes.privateGet(destIndexName);
            for (var i = 0; i < ids.length; i++) {
                // destIndex = destIndex.filter(k => k != ids[i]);
                if (destIndex.includes(ids[i]))
                    continue;
                // push or unshift id into current index
                destIndex[method](ids[i]);
            }
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: destIndexName,
                value: destIndex
            });
        }
    };
    Collection.prototype.put = function (ids, destIndexName, method) {
        if (method === void 0) { method = 'push'; }
        // validation
        if (!this.indexes.exists(destIndexName))
            return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
        if (!Array.isArray(ids))
            ids = [ids];
        // get current index
        var destIndex = this.indexes.privateGet(destIndexName);
        // This doesn't work because the array spead sets the object to index: value rather than just the values
        // let test = { ...destIndex };
        // ids.map(k => {
        //   if (test[k]) return;
        //   test[k] = true;
        // });
        // destIndex = Object.keys(test).map(k => Number(k));
        // loop over every id user is trying to add into current index
        for (var i = 0; i < ids.length; i++) {
            // destIndex = destIndex.filter(k => k != ids[i]);
            if (destIndex.includes(ids[i]))
                continue;
            // push or unshift id into current index
            destIndex[method](ids[i]);
        }
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: destIndexName,
            value: destIndex
        });
    };
    Collection.prototype.newGroup = function (groupName, indexValue) {
        if (this.indexes.object.hasOwnProperty(groupName))
            return assert(function (warn) { return warn.GROUP_ALREADY_EXISTS; });
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: groupName,
            value: indexValue
        });
    };
    Collection.prototype.deleteGroup = function (groupName) {
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: groupName,
            value: []
        });
    };
    Collection.prototype.removeFromGroup = function (groupName, itemsToRemove) {
        if (!this.indexes.exists(groupName))
            return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
        if (!Array.isArray(itemsToRemove))
            itemsToRemove = [itemsToRemove];
        var index = this.indexes.privateGet(groupName);
        var newIndex = index.filter(function (id) { return !itemsToRemove.includes(id); });
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: groupName,
            value: newIndex
        });
    };
    // internal data functions
    Collection.prototype.update = function (primaryKey, newObject) {
        if (!this.internalData.hasOwnProperty(primaryKey))
            return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; });
        var newObjectKeys = Object.keys(newObject);
        var currentData = Object.assign({}, this.internalData[primaryKey]);
        for (var i = 0; i < newObjectKeys.length; i++) {
            var key_1 = newObjectKeys[i];
            currentData[key_1] = newObject[key_1];
        }
        this.global.ingest({
            type: JobType.INTERNAL_DATA_MUTATION,
            collection: this.name,
            property: primaryKey,
            value: currentData
        });
    };
    Collection.prototype.increment = function (primaryKey, property, amount, decrement) {
        if (!this.internalData.hasOwnProperty(primaryKey))
            return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; });
        var currentData = Object.assign({}, this.internalData[primaryKey]);
        if (!validateNumber(amount, currentData[property]))
            return assert(function (warn) { return warn.PROPERTY_NOT_A_NUMBER; });
        if (decrement)
            currentData[property] -= amount;
        else
            currentData[property] += amount;
        this.global.ingest({
            type: JobType.INTERNAL_DATA_MUTATION,
            collection: this.name,
            property: primaryKey,
            value: currentData
        });
    };
    Collection.prototype.decrement = function (primaryKey, property, amount) {
        this.increment(primaryKey, property, amount, true);
    };
    Collection.prototype.delete = function (primaryKeys) {
        if (!Array.isArray(primaryKeys))
            primaryKeys = [primaryKeys];
        for (var i = 0; i < primaryKeys.length; i++) {
            var primaryKey = primaryKeys[i];
            this.global.ingest({
                type: JobType.DELETE_INTERNAL_DATA,
                collection: this.name,
                property: primaryKey
            });
        }
    };
    // remove all dynamic indexes, empty all indexes, delete all internal data
    Collection.prototype.purge = function () { };
    // external functions
    Collection.prototype.watch = function (property, callback) {
        if (!this.externalWatchers[property])
            this.externalWatchers[property] = [callback];
        else
            this.externalWatchers[property].push(callback);
    };
    Collection.prototype.forceUpdate = function (property) {
        // ensure property exists on collection
        if (this.public.exists(property)) {
            // if property is directly mutable
            if (this.public.mutable.includes(property)) {
                this.global.ingest({
                    type: JobType.PUBLIC_DATA_MUTATION,
                    property: property,
                    collection: this.name,
                    value: this.public.privateGet(property),
                    dep: this.global.getDep(property, this.name)
                });
                // if property is a computed method
            }
            else if (this.computed[property]) {
                this.global.ingest({
                    type: JobType.COMPUTED_REGEN,
                    property: property,
                    collection: this.name,
                    dep: this.global.getDep(property, this.name)
                });
            }
        }
    };
    // deprecate
    // added removeFromGroup to be more specific, params got switched around, keeping this for backwards compatibility
    Collection.prototype.remove = function (itemsToRemove, groupName) {
        return this.removeFromGroup(groupName, itemsToRemove);
    };
    return Collection;
}());
//# sourceMappingURL=collection.js.map

// This file handles external components subscribing to pulse.
var SubController = /** @class */ (function () {
    function SubController(getContext) {
        this.getContext = getContext;
        this.subscribingComponentKey = 0;
        this.subscribingComponent = false;
        this.unsubscribingComponent = false;
        this.skimmingDeepReactive = false;
        this.uuid = uuid;
        this.lastAccessedDep = null;
        this.componentStore = {};
    }
    SubController.prototype.registerComponent = function (instance, config) {
        var uuid = instance.__pulseUniqueIdentifier;
        if (!uuid) {
            // generate UUID
            uuid = this.uuid();
            // inject uuid into component instance
            var componentContainer = {
                instance: instance,
                uuid: uuid,
                ready: config.waitForMount ? false : true
            };
            instance.__pulseUniqueIdentifier = uuid;
            this.componentStore[uuid] = componentContainer;
        }
        else {
            this.mount(instance);
        }
        return uuid;
    };
    SubController.prototype.mount = function (instance) {
        var component = this.componentStore[instance.__pulseUniqueIdentifier];
        if (component) {
            component.instance = instance;
            component.ready = true;
        }
    };
    SubController.prototype.unmount = function (instance) {
        var uuid = instance.__pulseUniqueIdentifier;
        if (!uuid)
            return;
        // delete refrence to this component from store
        delete this.componentStore[instance.__pulseUniqueIdentifier];
    };
    SubController.prototype.subscribePropertiesToComponents = function (properties, componentUUID) {
        // provisionally get keys of mapped data
        var provision = properties(this.getContext());
        var keys = Object.keys(provision);
        // mapData has a user defined local key, we need to include that in the
        // subscription so we know what to update on the component later.
        this.subscribingComponentKey = 0;
        this.subscribingComponent = {
            componentUUID: componentUUID,
            keys: keys
        };
        var returnToComponent = properties(this.getContext());
        this.subscribingComponent = false;
        this.subscribingComponentKey = 0;
        // cleanse any deep objects of their getters/setters from Pulse and ensure object is a copy
        // Object.keys(returnToComponent).forEach(property => {
        //   returnToComponent[property] = cleanse(returnToComponent[property]);
        // });
        // returnToComponent = Object.assign({}, returnToComponent);
        // console.log(returnToComponent);
        return returnToComponent;
    };
    SubController.prototype.prepareNext = function (dep) {
        this.lastAccessedDep = dep;
        if (!this.skimmingDeepReactive)
            this.subscribingComponentKey++;
    };
    SubController.prototype.foundDeepReactive = function () {
        this.skimmingDeepReactive = true;
        // undo changes
        this.lastAccessedDep.subscribers.pop();
        this.subscribingComponentKey--;
    };
    SubController.prototype.exitDeepReactive = function () {
        this.skimmingDeepReactive = false;
        //redo changes
        this.lastAccessedDep.subscribe();
        this.subscribingComponentKey++;
    };
    return SubController;
}());
//# sourceMappingURL=subController.js.map

var Storage = /** @class */ (function () {
    function Storage(storageMethods) {
        if (storageMethods === void 0) { storageMethods = {}; }
        this.storageMethods = storageMethods;
        this.isPromise = false;
        this.storageReady = false;
        this.storageType = 'localStorage';
        if (storageMethods.async)
            this.isPromise = true;
        // assume if user provided get, set or remove methods that the storage type is custom
        if (storageMethods.get || storageMethods.set || storageMethods.remove) {
            this.storageType = 'custom';
        }
        if (this.localStorageAvaliable() && this.storageType === 'localStorage') {
            this.storageReady = true;
            storageMethods.get = localStorage.getItem.bind(localStorage);
            storageMethods.set = localStorage.setItem.bind(localStorage);
            storageMethods.remove = localStorage.removeItem.bind(localStorage);
        }
        else {
            this.storageType = 'custom';
            if (this.check(storageMethods.get) &&
                this.check(storageMethods.set) &&
                this.check(storageMethods.remove)) {
                this.storageReady = true;
            }
            else {
                this.storageReady = false;
                // bad
            }
        }
    }
    Storage.prototype.get = function (collection, key) {
        var _this = this;
        if (!this.storageReady)
            return;
        if (this.isPromise) {
            return new Promise(function (resolve, reject) {
                _this.storageMethods
                    .get(_this.getKey(collection, key))
                    .then(function (res) {
                    // if result is not JSON for some reason, return it.
                    if (typeof res !== 'string')
                        return resolve(res);
                    resolve(JSON.parse(res));
                })
                    .catch(reject);
            });
        }
        else {
            return JSON.parse(this.storageMethods.get(this.getKey(collection, key)));
        }
    };
    Storage.prototype.set = function (collection, key, value) {
        if (!this.storageReady)
            return;
        this.storageMethods.set(this.getKey(collection, key), JSON.stringify(value));
    };
    Storage.prototype.remove = function (collection, key) {
        if (!this.storageReady)
            return;
        this.storageMethods.remove(this.getKey(collection, key));
    };
    Storage.prototype.getKey = function (collection, key) {
        return "_" + collection + "_" + key;
    };
    Storage.prototype.check = function (func) {
        return typeof func === 'function';
    };
    Storage.prototype.localStorageAvaliable = function () {
        try {
            localStorage.setItem('_', '_');
            localStorage.removeItem('_');
            return true;
        }
        catch (e) {
            return false;
        }
    };
    return Storage;
}());
//# sourceMappingURL=storage.js.map

var Request = /** @class */ (function (_super) {
    __extends(Request, _super);
    function Request(global, requestConfig) {
        var _this = this;
        // Before we invoke the parent class, we define some defaults
        var groups = [];
        var persist = ['baseURL'];
        var data = {
            baseURL: requestConfig.baseURL || '',
            mode: 'cors',
            credentials: 'same-origin',
            headers: {
                Accept: 'application/json'
            }
        };
        if (requestConfig.headers)
            Object.keys(requestConfig.headers).forEach(function (header) {
                data.headers[header] = requestConfig.headers[header];
            });
        if (requestConfig.credentials)
            data.credentials = requestConfig.credentials;
        if (requestConfig.mode)
            data.mode = requestConfig.mode;
        _this = _super.call(this, 'request', global, { groups: groups, data: data, persist: persist }) || this;
        _this.requestIntercept = requestConfig.requestIntercept;
        _this.responseIntercept = requestConfig.responseIntercept;
        _this.timeout = requestConfig.timeout;
        _this.saveHistory =
            typeof requestConfig.saveHistory === 'undefined' ? true : false;
        _this.global.request = {
            get: _this.get.bind(_this),
            post: _this.post.bind(_this),
            put: _this._put.bind(_this),
            patch: _this.patch.bind(_this),
            delete: _this.delete.bind(_this),
            queryify: _this.queryify.bind(_this)
        };
        return _this;
    }
    Request.prototype.get = function (url, headers) {
        return this.send(url, 'get', {}, headers);
    };
    Request.prototype.post = function (url, body, headers) {
        return this.send(url, 'post', body, headers);
    };
    Request.prototype._put = function (url, body, headers) {
        return this.send(url, 'put', body, headers);
    };
    Request.prototype.patch = function (url, body, headers) {
        return this.send(url, 'patch', body, headers);
    };
    Request.prototype.delete = function (url, body, headers) {
        return this.send(url, 'delete', body, headers);
    };
    Request.prototype.send = function (url, method, body, headers) {
        if (body === void 0) { body = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestHeaders, fullURL, options, response, contentType, final, keys, i, property;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestHeaders = Object.assign({}, this.public.object.headers);
                        if (headers)
                            Object.keys(headers).forEach(function (header) {
                                requestHeaders[header] = headers[header];
                            });
                        // If method is not get set application type
                        if (method !== 'get' && requestHeaders['Content-Type'] === undefined)
                            requestHeaders['Content-Type'] = 'application/json';
                        if (url.startsWith('http'))
                            fullURL = url;
                        else
                            fullURL = this.public.object.baseURL + "/" + url;
                        // Stringify body
                        body = JSON.stringify(body);
                        // Build options
                        this.options = {};
                        this.options.credentials = this.public.object.credentials;
                        this.options.mode = this.public.object.mode;
                        options = Object.assign({
                            headers: requestHeaders,
                            method: method.toUpperCase(),
                            body: method === 'get' ? null : body
                        }, this.options);
                        if (this.requestIntercept)
                            this.requestIntercept(this.global.getContext('request'), options);
                        if (!this.timeout) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.race([
                                fetch(fullURL, options),
                                new Promise(function (resolve, reject) {
                                    return setTimeout(function () { return reject('timeout'); }, _this.timeout);
                                })
                            ])];
                    case 1:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, fetch(fullURL, options)];
                    case 3:
                        response = _a.sent();
                        _a.label = 4;
                    case 4:
                        contentType = response.headers.get('content-type');
                        if (!(contentType && contentType.indexOf('application/json') !== -1)) return [3 /*break*/, 6];
                        return [4 /*yield*/, response.json()];
                    case 5:
                        body = _a.sent();
                        return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, response.text()];
                    case 7:
                        body = _a.sent();
                        _a.label = 8;
                    case 8:
                        // history
                        if (!this.saveHistory)
                            this.collect({
                                id: Date.now(),
                                status: response.status,
                                timestamp: new Date(),
                                response: body
                            });
                        // If reponse body is an object, create a custom object with response function in prototype, so headers and the full response data can be accessed outside of this class
                        if (!Array.isArray(body) && typeof body === 'object') {
                            final = Object.create({
                                response: function () {
                                    return response;
                                }
                            });
                            keys = Object.keys(body);
                            for (i = 0; i < keys.length; i++) {
                                property = keys[i];
                                final[property] = body[property];
                            }
                            // if the body is not an object, we can not inject a prototype, so just return the rew body
                        }
                        else {
                            final = body;
                        }
                        // intercept response
                        if (this.responseIntercept) {
                            response.data = body;
                            this.responseIntercept(this.global.getContext('request'), response);
                        }
                        // reject if bad response status
                        if (response.ok || response.redirected)
                            return [2 /*return*/, final];
                        // resolve response
                        throw final;
                }
            });
        });
    };
    // Adapted from: https://github.com/Gozala/querystring/blob/master/encode.js
    Request.prototype.queryify = function (obj) {
        var stringifyPrimitive = function (value) {
            switch (typeof value) {
                case 'string':
                    return value;
                case 'boolean':
                    return value ? 'true' : 'false';
                case 'number':
                    return isFinite(value) ? value : '';
                default:
                    return '';
            }
        };
        // validate input
        if (typeof obj != 'object')
            return;
        return Object.keys(obj)
            .map(function (key) {
            var encodedKey = encodeURIComponent(stringifyPrimitive(key)) + '=';
            // if value is an array, encode with same key as parent
            if (Array.isArray(obj[key]))
                return obj[key]
                    .map(function (value) {
                    return encodedKey + encodeURIComponent(stringifyPrimitive(value));
                })
                    .join('&');
            // join encoded key with value
            return encodedKey + encodeURIComponent(stringifyPrimitive(obj[key]));
        })
            .join('&');
    };
    return Request;
}(Collection));
//# sourceMappingURL=request.js.map

var Request$1 = /** @class */ (function (_super) {
    __extends(Request, _super);
    function Request(global, root) {
        if (root === void 0) { root = {}; }
        var _this = this;
        root = Object.assign({}, root);
        // Base as a collection is configured directly from the root of the Pulse config,
        // thus to be verbose we remove the properties only used for global setup
        // default collection properties like data, computed, actions etc will remain
        delete root.collections;
        delete root.request;
        // if user has not created data or persist properties, create them for the defaults.
        if (!root.data)
            root.data = {};
        if (!root.persist)
            root.persist = [];
        // can be used to preserve authenticated state
        // automatically persists if local storage is availible
        root.data['isAuthenticated'] = false;
        root.persist.push('isAuthenticated');
        // can be used to declare once the app has finished initilazation, does not affect Pulse
        root.data['appReady'] = false;
        _this = _super.call(this, 'base', global, root) || this;
        return _this;
    }
    return Request;
}(Collection));
//# sourceMappingURL=base.js.map

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

var objectSpread = _objectSpread;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var createClass = _createClass;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var assertThisInitialized = _assertThisInitialized;

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

var possibleConstructorReturn = _possibleConstructorReturn;

var getPrototypeOf = createCommonjsModule(function (module) {
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
});

var setPrototypeOf = createCommonjsModule(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
});

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

var inherits = _inherits;

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function withPulse(pulse, React, ReactComponent, selectData) {
  return (
    /*#__PURE__*/
    function (_React$Component) {
      inherits(_class, _React$Component);

      function _class(props) {
        var _this;

        classCallCheck(this, _class);

        _this = possibleConstructorReturn(this, getPrototypeOf(_class).call(this, props));
        _this.state = objectSpread({}, pulse.mapData(selectData, assertThisInitialized(_this), {
          waitForMount: pulse._private.global.config.waitForMount === false ? false : true
        }, pulse));
        return _this;
      }

      createClass(_class, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          if (pulse._private.global.config.waitForMount) pulse.mount(this);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (pulse._private.global.config.autoUnmount) pulse.unmount(this);
        }
      }, {
        key: "render",
        value: function render() {
          return React.createElement(ReactComponent, _extends({
            pulse: this.state
          }, this.props));
        }
      }]);

      return _class;
    }(React.Component)
  );
}

var Library = /** @class */ (function () {
    function Library(root) {
        var _this = this;
        if (root === void 0) { root = {}; }
        // Private object contains all internal Pulse data
        this._private = {
            runtime: null,
            events: {},
            collections: {},
            collectionKeys: [],
            // global is passed in to all classes, must not contain cyclic references
            global: {
                config: this.prepareConfig(root.config),
                // State
                initComplete: false,
                runningAction: false,
                runningWatcher: false,
                runningComputed: false,
                runningPopulate: false,
                mappingData: false,
                collecting: false,
                touching: false,
                touched: false,
                contextRef: {},
                // Instances
                subs: new SubController(this.getContext.bind(this)),
                relations: null,
                storage: null,
                // Function aliases
                dispatch: this.dispatch.bind(this),
                getInternalData: this.getInternalData.bind(this),
                getContext: this.getContext.bind(this),
                getDep: this.getDep.bind(this),
                uuid: uuid
            }
        };
        // Bind static objects to instance (utils and services eventually should be initialized)
        ['utils', 'services', 'staticData'].forEach(function (type) {
            if (root[type])
                _this[type] = root[type];
        });
        // Create storage instance
        this._private.global.storage = new Storage(root.storage);
        // Create relation controller instance
        this._private.global.relations = new RelationController(this._private.global);
        // Prepare
        this.initCollections(root);
        this.initRuntime();
        // Finalize
        this.bindCollectionPublicData();
        this.runAllComputed();
        this.initComplete();
    }
    Library.prototype.initCollections = function (root) {
        this._private.collectionKeys = [];
        if (root.collections) {
            this._private.collectionKeys = Object.keys(root.collections).concat(this._private.collectionKeys);
            for (var i = 0; i < this._private.collectionKeys.length; i++) {
                // Create collection instance
                this._private.collections[this._private.collectionKeys[i]] = new Collection(this._private.collectionKeys[i], // name
                this._private.global, // global
                root.collections[this._private.collectionKeys[i]] // collection config
                );
            }
        }
        // Create request class
        if (this._private.global.config.enableRequest !== false)
            this._private.collectionKeys.push('request');
        this._private.collections['request'] = new Request(this._private.global, root.request || {});
        // Create base class
        if (this._private.global.config.enableBase !== false) {
            this._private.collectionKeys.push('base');
            this._private.collections['base'] = new Request$1(this._private.global, root);
        }
    };
    Library.prototype.initRuntime = function () {
        this._private.runtime = new Runtime(this._private.collections, this._private.global);
    };
    Library.prototype.bindCollectionPublicData = function () {
        for (var i = 0; i < this._private.collectionKeys.length; i++) {
            var collection = this._private.collections[this._private.collectionKeys[i]];
            this._private.global.contextRef[this._private.collectionKeys[i]] =
                collection.public.object;
            this[this._private.collectionKeys[i]] = collection.public.object;
        }
    };
    Library.prototype.runAllComputed = function () {
        for (var i = 0; i < this._private.collectionKeys.length; i++) {
            var collection = this._private.collections[this._private.collectionKeys[i]];
            var computedKeys = collection.keys.computed;
            for (var i_1 = 0; i_1 < computedKeys.length; i_1++) {
                var computedName = computedKeys[i_1];
                this._private.runtime.performComputedOutput({
                    collection: collection.name,
                    property: computedName,
                    type: JobType.COMPUTED_REGEN
                });
                collection.runWatchers(computedName);
            }
        }
    };
    Library.prototype.initComplete = function () {
        this._private.global.initComplete = true;
        log('INIT COMPLETE', Object.assign({}, this));
        if (!this._private.global.config.ssr) {
            try {
                window._pulse = this;
            }
            catch (e) { }
        }
    };
    Library.prototype.wrapped = function (ReactComponent, mapData) {
        var config = this._private.global.config;
        if (config.framework === 'react' && config.frameworkConstructor) {
            return withPulse(this, config.frameworkConstructor, ReactComponent, mapData);
        }
        else
            return false;
    };
    Library.prototype.prepareConfig = function (config) {
        // defaults
        config = defineConfig(config, {
            framework: null,
            waitForMount: false,
            autoUnmount: false
        });
        // detect if framework passed in is a React constructor
        if (config.framework &&
            config.framework.hasOwnProperty('__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED')) {
            config.frameworkConstructor = config.framework;
            config.framework = 'react';
        }
        if (config.framework === 'react') {
            if (config.waitForMount != false)
                config.waitForMount = true;
            if (config.autoUnmount != false)
                config.autoUnmount = true;
        }
        return config;
    };
    Library.prototype.getInternalData = function (collection, primaryKey) {
        return this._private.collections[collection].findById(primaryKey);
    };
    // returns Dep instance by "touching" reactive property revealing its Dep class
    // if collection param is present we'll assume the property param is the name of the property, not a reference to the property itself
    Library.prototype.getDep = function (property, collection, forData) {
        var dep;
        // if forData is true we'll go straight for the internal dep
        if (!forData) {
            // "touching" is simply invoking the property's getter
            this._private.global.touching = true;
            if (typeof collection === 'string') {
                this._private.collections[collection].public.object[property];
            }
            else if (typeof collection === 'object') {
                collection[property];
            }
            // Extract the dep
            dep = this._private.global.touched;
            this._private.global.touching = false;
            this._private.global.touched = null;
            // if still no dep found, look inward lol
            if (!dep)
                dep = this._private.collections[collection].internalDataDeps[property];
        }
        else {
            dep = this._private.collections[collection].internalDataDeps[property];
        }
        return dep;
    };
    Library.prototype.dispatch = function (type, payload) {
        switch (type) {
            case 'mutation':
                this._private.runtime.ingest({
                    type: JobType.PUBLIC_DATA_MUTATION,
                    collection: payload.collection,
                    property: payload.key,
                    value: payload.value,
                    dep: payload.dep
                });
                break;
            default:
                break;
        }
    };
    Library.prototype.getContext = function (collection) {
        var c = this._private.collections[collection];
        if (!c)
            return this._private.global.contextRef;
        return __assign({}, this._private.global.contextRef, c.methods, { data: c.public.object, indexes: c.indexes.object, groups: c.public.object, computed: c.public.object, routes: c.public.object.routes, local: c.local });
    };
    Library.prototype.install = function (Vue) {
        this._private.global.config.framework = 'vue';
        var pulse = this;
        var config = pulse._private.global.config;
        Vue.mixin({
            beforeCreate: function () {
                var _this = this;
                Object.keys(pulse._private.global.contextRef).forEach(function (collection) {
                    _this['$' + collection] = pulse._private.global.contextRef[collection];
                });
                if (pulse.utils)
                    this.$utils = pulse.utils;
                if (pulse.services)
                    this.$services = pulse.services;
                if (pulse.staticData)
                    this.$staticData = pulse.staticData;
                this.mapData = function (properties) {
                    return pulse.mapData(properties, _this, {
                        waitForMount: config.waitForMount
                    }, pulse);
                };
            },
            mounted: function () {
                if (this.__pulseUniqueIdentifier && config.waitForMount)
                    pulse.mount(this);
            },
            beforeDestroy: function () {
                if (this.__pulseUniqueIdentifier && config.autoUnmount)
                    pulse.unmount(this);
            }
        });
    };
    Library.prototype.mount = function (instance) {
        this._private.global.subs.mount(instance);
    };
    Library.prototype.unmount = function (instance) {
        this._private.global.subs.unmount(instance);
    };
    Library.prototype.mapData = function (properties, instance, _config, pulseAlias) {
        if (instance === void 0) { instance = {}; }
        if (_config === void 0) { _config = {}; }
        var pulse = pulseAlias ? pulseAlias : this;
        var config = __assign({ waitForMount: true }, _config);
        var componentUUID = pulse._private.global.subs.registerComponent(instance, config);
        this._private.global.mappingData = true;
        // new cool mapData method
        if (typeof properties === 'function') {
            return pulse._private.global.subs.subscribePropertiesToComponents(properties, componentUUID);
            // legacy support....
        }
        else if (typeof properties === 'object') {
            var returnData_1 = {};
            normalizeMap(properties).forEach(function (_a) {
                var key = _a.key, val = _a.val;
                var collection = val.split('/')[0];
                var property = val.split('/')[1];
                var c = pulse._private.global.getContext()[collection];
                returnData_1[key] = pulse._private.global.subs.subscribePropertiesToComponents(function () {
                    var _a;
                    return _a = {}, _a[key] = c[property], _a;
                }, componentUUID)[key];
            });
            this._private.global.mappingData = false;
            returnData_1 = cleanse(returnData_1);
            return returnData_1;
        }
    };
    Library.prototype.emit = function (name, payload) {
        if (this._private.events[name])
            for (var i = 0; i < this._private.events[name].length; i++) {
                var callback = this._private.events[name][i];
                callback(payload);
            }
    };
    Library.prototype.on = function (name, callback) {
        if (!Array.isArray(this._private.events[name]))
            this._private.events[name] = [callback];
        else
            this._private.events[name].push(callback);
    };
    Library.prototype.log = function (type) {
        // let debugMode: Set<DebugType> = this._private.global.config.debugMode;
        // if (debugMode.size === 0) return;
        // if (debugMode.has(DebugType.ERRORS)) {
        // }
        // log(DebugType.ASSERT, `There was an error with "${thing}", bad :(`);
        // const AssertMessages = {
        //   INDEX_UPDATE_FAILED: (collection, property) =>
        //     `The type ${collection} is ${property}.`
        //   // and more
        // };
        // function _log(callback) {
        // }
        // _log(({ AssertMessages }) => AssertMessages.INDEX_UPDATE_FAILED(thing, thing2));
    };
    return Library;
}());
//# sourceMappingURL=library.js.map

//# sourceMappingURL=index.js.map

export default Library;
//# sourceMappingURL=pulse.esm.min.js.map
